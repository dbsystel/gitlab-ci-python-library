<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2" />
<title>gcip.core.sequence API documentation</title>
<meta name="description" content="A Sequence collects multiple `gcip.core.job.Job`s and/or other `gcip.core.sequence.Sequence`s into a group …" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>gcip.core.sequence</code></h1>
</header>
<section id="section-intro">
<p>A Sequence collects multiple <code><a title="gcip.core.job.Job" href="job.html#gcip.core.job.Job">Job</a></code>s and/or other <code><a title="gcip.core.sequence.Sequence" href="#gcip.core.sequence.Sequence">Sequence</a></code>s into a group.</p>
<p>This concept is no official representation of a Gitlab CI keyword. But it is such a powerful
extension of the Gitlab CI core funtionality and an essential building block of the gcip, that
it is conained in the <code><a title="gcip.core" href="index.html">gcip.core</a></code> module.</p>
<p>A Sequence offers a mostly similar interface like <code><a title="gcip.core.job.Job" href="job.html#gcip.core.job.Job">Job</a></code>s that allows to modify
all Jobs and child Sequences contained into that parent Sequence. For example: Instad of calling
<code>add_tag()</code> on a dozens of Jobs you can call <code>add_tag()</code> on the sequence that contain those Jobs.
The tag will then be applied to all Jobs in that Sequence and recursively to all Jobs within child
Sequenes of that Sequence.</p>
<p>Sequences must be added to a <code><a title="gcip.core.pipeline.Pipeline" href="pipeline.html#gcip.core.pipeline.Pipeline">Pipeline</a></code>, either directly or as part of other Sequences.
That means Sequences are not meant to be a throw away configuration container for a bunch ob Jobs.
This is because adding a Job to a Sequence creates a copy of that Job, which will be inderectly added to
the <code>Pipeline</code> by that Sequence. Not adding that Sequence to a Pipeline means also not adding its Jobs
to the Pipeline. If other parts of the Pipeline have dependencies to those Jobs, they will be broken.</p>
<p>As said before, adding a Job to a Sequence creates copies of that Job. To void conflicts between Jobs,
you should set <code>name</code> and/or <code>namespace</code> when adding the job (or child sequence). The sequence will add
the <code>name</code> / <code>namespace</code> to the ones of the Job, when rendering the pipeline. If you do not set those
identifiers, or you set equal name/namespaces for jobs and sequences, you provoke having two or more
jobs having the same name in the pipeline. The gcip will raise a ValueError, to avoid unexpected
pipeline behavior. You can read more information in the chapter "Namespaces allow reuse of jobs
and sequences" of the user documantation.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;A Sequence collects multiple `gcip.core.job.Job`s and/or other `gcip.core.sequence.Sequence`s into a group.

This concept is no official representation of a Gitlab CI keyword. But it is such a powerful
extension of the Gitlab CI core funtionality and an essential building block of the gcip, that
it is conained in the `gcip.core` module.

A Sequence offers a mostly similar interface like `gcip.core.job.Job`s that allows to modify
all Jobs and child Sequences contained into that parent Sequence. For example: Instad of calling
`add_tag()` on a dozens of Jobs you can call `add_tag()` on the sequence that contain those Jobs.
The tag will then be applied to all Jobs in that Sequence and recursively to all Jobs within child
Sequenes of that Sequence.

Sequences must be added to a `gcip.core.pipeline.Pipeline`, either directly or as part of other Sequences.
That means Sequences are not meant to be a throw away configuration container for a bunch ob Jobs.
This is because adding a Job to a Sequence creates a copy of that Job, which will be inderectly added to
the `Pipeline` by that Sequence. Not adding that Sequence to a Pipeline means also not adding its Jobs
to the Pipeline. If other parts of the Pipeline have dependencies to those Jobs, they will be broken.

As said before, adding a Job to a Sequence creates copies of that Job. To void conflicts between Jobs,
you should set `name` and/or `namespace` when adding the job (or child sequence). The sequence will add
the `name` / `namespace` to the ones of the Job, when rendering the pipeline. If you do not set those
identifiers, or you set equal name/namespaces for jobs and sequences, you provoke having two or more
jobs having the same name in the pipeline. The gcip will raise a ValueError, to avoid unexpected
pipeline behavior. You can read more information in the chapter &#34;Namespaces allow reuse of jobs
and sequences&#34; of the user documantation.
&#34;&#34;&#34;
from __future__ import annotations

import copy
from typing import (
    Set,
    Dict,
    List,
    Union,
    Optional,
    TypedDict,
)

from . import OrderedSetType
from .job import Job
from .need import Need
from .rule import Rule
from .cache import Cache
from .image import Image

__author__ = &#34;Thomas Steinbach&#34;
__copyright__ = &#34;Copyright 2020 DB Systel GmbH&#34;
__credits__ = [&#34;Thomas Steinbach&#34;, &#34;Daniel von Eßen&#34;]
# SPDX-License-Identifier: Apache-2.0
__license__ = &#34;Apache-2.0&#34;
__maintainer__ = &#34;Thomas Steinbach&#34;
__email__ = &#34;thomas.t.steinbach@deutschebahn.com&#34;


class ChildDict(TypedDict):
    &#34;&#34;&#34;This data structure is supposed to store one child of a `Sequence` with all required information about that child.&#34;&#34;&#34;

    child: Union[Job, Sequence]
    &#34;&#34;&#34;The child to store - a `gcip.core.job.Job` or `Sequence`.&#34;&#34;&#34;
    namespace: Optional[str]
    &#34;&#34;&#34;The namespace with whom the `child` was added to the `Sequence`.&#34;&#34;&#34;
    name: Optional[str]
    &#34;&#34;&#34;The name with whom the `child` was added to the `Sequence`.&#34;&#34;&#34;


class Sequence:
    &#34;&#34;&#34;A Sequence collects multiple `gcip.core.job.Job`s and/or other `gcip.core.sequence.Sequence`s into a group.&#34;&#34;&#34;

    def __init__(self) -&gt; None:
        super().__init__()
        self._children: List[ChildDict] = list()
        self._image_for_initialization: Optional[Union[Image, str]] = None
        self._image_for_replacement: Optional[Union[Image, str]] = None
        self._variables: Dict[str, str] = {}
        self._variables_for_initialization: Dict[str, str] = {}
        self._variables_for_replacement: Dict[str, str] = {}
        self._tags: OrderedSetType = {}
        self._tags_for_initialization: OrderedSetType = {}
        self._tags_for_replacement: OrderedSetType = {}
        self._artifacts_paths: OrderedSetType = {}
        self._artifacts_paths_for_initialization: OrderedSetType = {}
        self._artifacts_paths_for_replacement: OrderedSetType = {}
        self._cache: Optional[Cache] = None
        self._cache_for_initialization: Optional[Cache] = None
        self._scripts_to_prepend: List[str] = []
        self._scripts_to_append: List[str] = []
        self._rules_to_append: List[Rule] = []
        self._rules_to_prepend: List[Rule] = []
        self._rules_for_initialization: List[Rule] = []
        self._rules_for_replacement: List[Rule] = []
        self._needs: List[Union[Job, Need]] = []
        self._parents: List[Sequence] = list()

    def _add_parent(self, parent: Sequence) -&gt; None:
        self._parents.append(parent)

    def add_children(
        self,
        *jobs_or_sequences: Union[Job, Sequence],
        namespace: Optional[str] = None,
        name: Optional[str] = None,
    ) -&gt; Sequence:
        &#34;&#34;&#34;Add `gcip.core.job.Job`s or other `gcip.core.sequence.Sequence`s to this sequence.

        Adding a child creates a copy of that child. You should provide a name or namespace
        when adding children, to make them different from other places where they will be used.

        Args:
            jobs_or_sequences (Union[Job, Sequence]): One or more jobs or sequences to be added to this sequence.
            namespace (Optional[str], optional): Adds a namespaces component to all children added. Defaults to None.
            name (Optional[str], optional): Adds a name component to all children added. Defaults to None.

        Returns:
            `Sequence`: The modified `Sequence` object.
        &#34;&#34;&#34;
        for child in jobs_or_sequences:
            child._add_parent(self)
            self._children.append({&#34;child&#34;: child, &#34;namespace&#34;: namespace, &#34;name&#34;: name})
        return self

    def add_variables(self, **variables: str) -&gt; Sequence:
        &#34;&#34;&#34;Calling `gcip.core.job.Job.add_variables()` to all jobs within this sequence.

        Returns:
            `Sequence`: The modified `Sequence` object.
        &#34;&#34;&#34;
        self._variables.update(variables)
        return self

    def initialize_variables(self, **variables: str) -&gt; Sequence:
        &#34;&#34;&#34;Calling `gcip.core.job.Job.add_variables()` to all jobs within this sequence that haven&#39;t been added variables before.

        Returns:
            `Sequence`: The modified `Sequence` object.
        &#34;&#34;&#34;
        self._variables_for_initialization.update(variables)
        return self

    def override_variables(self, **variables: str) -&gt; Sequence:
        &#34;&#34;&#34;Calling `gcip.core.job.Job.add_variables()` to all jobs within this sequence and overriding any previously added variables to that jobs.

        Returns:
            `Sequence`: The modified `Sequence` object.
        &#34;&#34;&#34;
        self._variables_for_replacement.update(variables)
        return self

    def set_cache(self, cache: Cache) -&gt; Sequence:
        &#34;&#34;&#34;Calling `gcip.core.job.Job.set_cache()` to all jobs within this sequence.

        Returns:
            `Sequence`: The modified `Sequence` object.
        &#34;&#34;&#34;
        self._cache = cache
        return self

    def initialize_cache(self, cache: Cache) -&gt; Sequence:
        &#34;&#34;&#34;Calling `gcip.core.job.Job.set_cache()` to all jobs within this sequence that haven&#39;t been set the cache before.

        Returns:
            `Sequence`: The modified `Sequence` object.
        &#34;&#34;&#34;
        self._cache_for_initialization = cache
        return self

    def add_tags(self, *tags: str) -&gt; Sequence:
        &#34;&#34;&#34;Calling `gcip.core.job.Job.add_tags()` to all jobs within this sequence.

        Returns:
            `Sequence`: The modified `Sequence` object.
        &#34;&#34;&#34;
        for tag in tags:
            self._tags[tag] = None
        return self

    def initialize_tags(self, *tags: str) -&gt; Sequence:
        &#34;&#34;&#34;Calling `gcip.core.job.Job.add_tags()` to all jobs within this sequence that haven&#39;t been added tags before.

        Returns:
            `Sequence`: The modified `Sequence` object.
        &#34;&#34;&#34;
        for tag in tags:
            self._tags_for_initialization[tag] = None
        return self

    def override_tags(self, *tags: str) -&gt; Sequence:
        &#34;&#34;&#34;Calling `gcip.core.job.Job.add_tags()` to all jobs within this sequence and overriding any previously added tags to that jobs.

        Returns:
            `Sequence`: The modified `Sequence` object.
        &#34;&#34;&#34;
        for tag in tags:
            self._tags_for_replacement[tag] = None
        return self

    def add_artifacts_paths(self, *paths: str) -&gt; Sequence:
        &#34;&#34;&#34;Calling `gcip.core.job.Job.add_artifacts_paths()` to all jobs within this sequence.

        Returns:
            `Sequence`: The modified `Sequence` object.
        &#34;&#34;&#34;
        for path in paths:
            self._artifacts_paths[path] = None
        return self

    def initialize_artifacts_paths(self, *paths: str) -&gt; Sequence:
        &#34;&#34;&#34;Calling `gcip.core.job.Job.add_artifacts_paths()` to all jobs within this sequence that haven&#39;t been added artifacts paths before.

        Returns:
            `Sequence`: The modified `Sequence` object.
        &#34;&#34;&#34;
        for path in paths:
            self._artifacts_paths_for_initialization[path] = None
        return self

    def override_artifacts_paths(self, *paths: str) -&gt; Sequence:
        &#34;&#34;&#34;Calling `gcip.core.job.Job.add_artifacts_paths()` to all jobs within this sequence and overriding any previously added artifacts paths to that jobs.

        Returns:
            `Sequence`: The modified `Sequence` object.
        &#34;&#34;&#34;
        for path in paths:
            self._artifacts_paths_for_replacement[path] = None
        return self

    def append_rules(self, *rules: Rule) -&gt; Sequence:
        &#34;&#34;&#34;Calling `gcip.core.job.Job.append_rules()` to all jobs within this sequence.

        Returns:
            `Sequence`: The modified `Sequence` object.
        &#34;&#34;&#34;
        self._rules_to_append.extend(rules)
        return self

    def prepend_rules(self, *rules: Rule) -&gt; Sequence:
        &#34;&#34;&#34;Calling `gcip.core.job.Job.prepend_rules()` to all jobs within this sequence.

        Returns:
            `Sequence`: The modified `Sequence` object.
        &#34;&#34;&#34;
        self._rules_to_prepend = list(rules) + self._rules_to_prepend
        return self

    def initialize_rules(self, *rules: Rule) -&gt; Sequence:
        &#34;&#34;&#34;Calling `gcip.core.job.Job.append_rules()` to all jobs within this sequence that haven&#39;t been added rules before.

        Returns:
            `Sequence`: The modified `Sequence` object.
        &#34;&#34;&#34;
        self._rules_for_initialization.extend(rules)
        return self

    def override_rules(self, *rules: Rule) -&gt; Sequence:
        &#34;&#34;&#34;Calling `gcip.core.job.Job.override_rules()` to all jobs within this sequence and overriding any previously added rules to that jobs.

        Returns:
            `Sequence`: The modified `Sequence` object.
        &#34;&#34;&#34;
        self._rules_for_replacement.extend(rules)
        return self

    def add_needs(self, *needs: Union[Job, Need]) -&gt; Sequence:
        &#34;&#34;&#34;Calling `gcip.core.job.Job.add_need()` to all jobs within the first stage of this sequence.

        Returns:
            `Sequence`: The modified `Sequence` object.
        &#34;&#34;&#34;
        self._needs.extend(needs)
        return self

    def prepend_scripts(self, *scripts: str) -&gt; Sequence:
        &#34;&#34;&#34;Calling `gcip.core.job.Job.prepend_scripts()` to all jobs within this sequence.

        Returns:
            `Sequence`: The modified `Sequence` object.
        &#34;&#34;&#34;
        self._scripts_to_prepend = list(scripts) + self._scripts_to_prepend
        return self

    def append_scripts(self, *scripts: str) -&gt; Sequence:
        &#34;&#34;&#34;Calling `gcip.core.job.Job.append_scripts()` to all jobs within this sequence.

        Returns:
            `Sequence`: The modified `Sequence` object.
        &#34;&#34;&#34;
        self._scripts_to_append.extend(scripts)
        return self

    def initialize_image(self, image: Union[Image, str]) -&gt; Sequence:
        &#34;&#34;&#34;Calling `gcip.core.job.Job.set_image()` to all jobs within this sequence.

        Returns:
            `Sequence`: The modified `Sequence` object.
        &#34;&#34;&#34;
        if image:
            self._image_for_initialization = image
        return self

    def override_image(self, image: Union[Image, str]) -&gt; Sequence:
        &#34;&#34;&#34;Calling `gcip.core.job.Job.set_image()` to all jobs within this sequence that haven&#39;t been set the image before.

        Returns:
            `Sequence`: The modified `Sequence` object.
        &#34;&#34;&#34;
        if image:
            self._image_for_replacement = image
        return self

    def _get_all_instance_names(self, child: Union[Job, Sequence]) -&gt; Set[str]:
        &#34;&#34;&#34;Return all instance names from the given child.

        That means all combinations of the childs name and namespace within this
        sequence and all parent sequences.
        &#34;&#34;&#34;

        # first get all instance names from parents of this sequence
        own_instance_names: Set[str] = set()
        for parent in self._parents:
            own_instance_names.update(parent._get_all_instance_names(self))

        # second get all instance names of the child within this sequence
        child_instance_names: Set[str] = set()
        child_instance_name: str
        for item in self._children:
            if item[&#34;child&#34;] == child:
                child_name = item[&#34;name&#34;]
                child_namespace = item[&#34;namespace&#34;]
                if child_namespace:
                    if child_name:
                        child_instance_name = f&#34;{child_namespace}-{child_name}&#34;
                    else:
                        child_instance_name = child_namespace
                elif child_name:
                    child_instance_name = child_name
                else:
                    child_instance_name = &#34;&#34;

                # all job names have &#39;-&#39; instead of &#39;_&#39;
                child_instance_names.add(child_instance_name.replace(&#34;_&#34;, &#34;-&#34;))

        # third combine all instance names of this sequences
        # with all instance names of the child
        return_values: Set[str] = set()
        if own_instance_names:
            for child_instance_name in child_instance_names:
                for instance_name in own_instance_names:
                    if child_instance_name:
                        return_values.add(f&#34;{child_instance_name}-{instance_name}&#34;)
                    else:
                        return_values.add(instance_name)
        else:
            return_values = child_instance_names

        return return_values

    @property
    def last_jobs_executed(self) -&gt; List[Job]:
        &#34;&#34;&#34;This property returns all Jobs from the last stage of this sequence.

        This is typically be requested from a job which has setup this sequence as need,
        to determine all actual jobs of this sequence as need.
        &#34;&#34;&#34;
        all_jobs = self.populated_jobs
        stages: Dict[str, None] = {}
        for job in all_jobs:
            # use the keys of dictionary as ordered set
            stages[job.stage] = None

        last_stage = list(stages.keys())[-1]
        last_executed_jobs: List[Job] = list()
        for job in all_jobs:
            if job._stage == last_stage:
                if job._original:
                    last_executed_jobs.append(job._original)
                else:
                    raise AttributeError(&#34;job._original is None, because the job is not a copy of another job&#34;)

        return last_executed_jobs

    @property
    def populated_jobs(self) -&gt; List[Job]:
        &#34;&#34;&#34;Returns a list with populated copies of all nested jobs of this sequence.

        Populated means, that all attributes of a Job which depends on its context are resolved
        to their final values. The context is primarily the sequence within the jobs resides but
        also dependencies to other jobs and sequences. Thus this sequence will apply its own
        configuration, like variables to add, tags to set, etc., to all its jobs and sequences.

        Copies means what it says, that the returned job are not the same job objects, originally
        added to this sequence, but copies of them.

        Nested means, that also jobs from sequences within this sequence, are returned, as well
        as jobs from sequences within sequences within this sequence and so on.

        Returns:
            List[Job]: A list of copies of all nested jobs of this sequence with their final attribute values.
        &#34;&#34;&#34;
        all_jobs: List[Job] = []
        for item in self._children:
            child = item[&#34;child&#34;]
            child_name = item[&#34;name&#34;]
            child_namespace = item[&#34;namespace&#34;]
            if isinstance(child, Sequence):
                for job_copy in child.populated_jobs:
                    job_copy._extend_namespace(child_namespace)
                    job_copy._extend_name(child_name)
                    all_jobs.append(job_copy)
            elif isinstance(child, Job):
                job_copy = child.copy()
                job_copy._extend_namespace(child_namespace)
                job_copy._extend_name(child_name)
                all_jobs.append(job_copy)

        if len(all_jobs) &gt; 0:
            first_job = all_jobs[0]
            first_job.add_needs(*self._needs)
            for job in all_jobs[1:]:
                if job._stage == first_job.stage:
                    job.add_needs(*self._needs)

        for job in all_jobs:

            if self._image_for_initialization and not job._image:
                job.set_image(self._image_for_initialization)
            if self._image_for_replacement:
                job.set_image(self._image_for_replacement)

            if self._variables_for_initialization and not job._variables:
                job._variables = copy.deepcopy(self._variables_for_initialization)
            if self._variables_for_replacement:
                job._variables = copy.deepcopy(self._variables_for_replacement)
            job.add_variables(**copy.deepcopy(self._variables))

            if self._cache_for_initialization and not job._cache:
                job._cache = copy.deepcopy(self._cache_for_initialization)
            job.set_cache(copy.deepcopy(self._cache))

            if self._tags_for_initialization and not job._tags:
                job._tags = copy.deepcopy(self._tags_for_initialization)
            if self._tags_for_replacement:
                job._tags = copy.deepcopy(self._tags_for_replacement)
            job.add_tags(*list(self._tags.keys()))

            if self._artifacts_paths_for_initialization and not job._artifacts_paths:
                job._artifacts_paths = copy.deepcopy(self._artifacts_paths_for_initialization)
            if self._artifacts_paths_for_replacement:
                job._artifacts_paths = copy.deepcopy(self._artifacts_paths_for_replacement)
            job.add_artifacts_paths(*list(self._artifacts_paths.keys()))

            if self._rules_for_initialization and not job._rules:
                job._rules = copy.deepcopy(self._rules_for_initialization)
            if self._rules_for_replacement:
                job._rules = copy.deepcopy(self._rules_for_replacement)
            job.append_rules(*self._rules_to_append)
            job.prepend_rules(*self._rules_to_prepend)

            job.prepend_scripts(*self._scripts_to_prepend)
            job.append_scripts(*self._scripts_to_append)

        return all_jobs</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="gcip.core.sequence.ChildDict"><code class="flex name class">
<span>class <span class="ident">ChildDict</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>This data structure is supposed to store one child of a <code><a title="gcip.core.sequence.Sequence" href="#gcip.core.sequence.Sequence">Sequence</a></code> with all required information about that child.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ChildDict(TypedDict):
    &#34;&#34;&#34;This data structure is supposed to store one child of a `Sequence` with all required information about that child.&#34;&#34;&#34;

    child: Union[Job, Sequence]
    &#34;&#34;&#34;The child to store - a `gcip.core.job.Job` or `Sequence`.&#34;&#34;&#34;
    namespace: Optional[str]
    &#34;&#34;&#34;The namespace with whom the `child` was added to the `Sequence`.&#34;&#34;&#34;
    name: Optional[str]
    &#34;&#34;&#34;The name with whom the `child` was added to the `Sequence`.&#34;&#34;&#34;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.dict</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="gcip.core.sequence.ChildDict.child"><code class="name">var <span class="ident">child</span> : Union[<a title="gcip.core.job.Job" href="job.html#gcip.core.job.Job">Job</a>, <a title="gcip.core.sequence.Sequence" href="#gcip.core.sequence.Sequence">Sequence</a>]</code></dt>
<dd>
<div class="desc"><p>The child to store - a <code><a title="gcip.core.job.Job" href="job.html#gcip.core.job.Job">Job</a></code> or <code><a title="gcip.core.sequence.Sequence" href="#gcip.core.sequence.Sequence">Sequence</a></code>.</p></div>
</dd>
<dt id="gcip.core.sequence.ChildDict.name"><code class="name">var <span class="ident">name</span> : Optional[str]</code></dt>
<dd>
<div class="desc"><p>The name with whom the <code>child</code> was added to the <code><a title="gcip.core.sequence.Sequence" href="#gcip.core.sequence.Sequence">Sequence</a></code>.</p></div>
</dd>
<dt id="gcip.core.sequence.ChildDict.namespace"><code class="name">var <span class="ident">namespace</span> : Optional[str]</code></dt>
<dd>
<div class="desc"><p>The namespace with whom the <code>child</code> was added to the <code><a title="gcip.core.sequence.Sequence" href="#gcip.core.sequence.Sequence">Sequence</a></code>.</p></div>
</dd>
</dl>
</dd>
<dt id="gcip.core.sequence.Sequence"><code class="flex name class">
<span>class <span class="ident">Sequence</span></span>
</code></dt>
<dd>
<div class="desc"><p>A Sequence collects multiple <code><a title="gcip.core.job.Job" href="job.html#gcip.core.job.Job">Job</a></code>s and/or other <code><a title="gcip.core.sequence.Sequence" href="#gcip.core.sequence.Sequence">Sequence</a></code>s into a group.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Sequence:
    &#34;&#34;&#34;A Sequence collects multiple `gcip.core.job.Job`s and/or other `gcip.core.sequence.Sequence`s into a group.&#34;&#34;&#34;

    def __init__(self) -&gt; None:
        super().__init__()
        self._children: List[ChildDict] = list()
        self._image_for_initialization: Optional[Union[Image, str]] = None
        self._image_for_replacement: Optional[Union[Image, str]] = None
        self._variables: Dict[str, str] = {}
        self._variables_for_initialization: Dict[str, str] = {}
        self._variables_for_replacement: Dict[str, str] = {}
        self._tags: OrderedSetType = {}
        self._tags_for_initialization: OrderedSetType = {}
        self._tags_for_replacement: OrderedSetType = {}
        self._artifacts_paths: OrderedSetType = {}
        self._artifacts_paths_for_initialization: OrderedSetType = {}
        self._artifacts_paths_for_replacement: OrderedSetType = {}
        self._cache: Optional[Cache] = None
        self._cache_for_initialization: Optional[Cache] = None
        self._scripts_to_prepend: List[str] = []
        self._scripts_to_append: List[str] = []
        self._rules_to_append: List[Rule] = []
        self._rules_to_prepend: List[Rule] = []
        self._rules_for_initialization: List[Rule] = []
        self._rules_for_replacement: List[Rule] = []
        self._needs: List[Union[Job, Need]] = []
        self._parents: List[Sequence] = list()

    def _add_parent(self, parent: Sequence) -&gt; None:
        self._parents.append(parent)

    def add_children(
        self,
        *jobs_or_sequences: Union[Job, Sequence],
        namespace: Optional[str] = None,
        name: Optional[str] = None,
    ) -&gt; Sequence:
        &#34;&#34;&#34;Add `gcip.core.job.Job`s or other `gcip.core.sequence.Sequence`s to this sequence.

        Adding a child creates a copy of that child. You should provide a name or namespace
        when adding children, to make them different from other places where they will be used.

        Args:
            jobs_or_sequences (Union[Job, Sequence]): One or more jobs or sequences to be added to this sequence.
            namespace (Optional[str], optional): Adds a namespaces component to all children added. Defaults to None.
            name (Optional[str], optional): Adds a name component to all children added. Defaults to None.

        Returns:
            `Sequence`: The modified `Sequence` object.
        &#34;&#34;&#34;
        for child in jobs_or_sequences:
            child._add_parent(self)
            self._children.append({&#34;child&#34;: child, &#34;namespace&#34;: namespace, &#34;name&#34;: name})
        return self

    def add_variables(self, **variables: str) -&gt; Sequence:
        &#34;&#34;&#34;Calling `gcip.core.job.Job.add_variables()` to all jobs within this sequence.

        Returns:
            `Sequence`: The modified `Sequence` object.
        &#34;&#34;&#34;
        self._variables.update(variables)
        return self

    def initialize_variables(self, **variables: str) -&gt; Sequence:
        &#34;&#34;&#34;Calling `gcip.core.job.Job.add_variables()` to all jobs within this sequence that haven&#39;t been added variables before.

        Returns:
            `Sequence`: The modified `Sequence` object.
        &#34;&#34;&#34;
        self._variables_for_initialization.update(variables)
        return self

    def override_variables(self, **variables: str) -&gt; Sequence:
        &#34;&#34;&#34;Calling `gcip.core.job.Job.add_variables()` to all jobs within this sequence and overriding any previously added variables to that jobs.

        Returns:
            `Sequence`: The modified `Sequence` object.
        &#34;&#34;&#34;
        self._variables_for_replacement.update(variables)
        return self

    def set_cache(self, cache: Cache) -&gt; Sequence:
        &#34;&#34;&#34;Calling `gcip.core.job.Job.set_cache()` to all jobs within this sequence.

        Returns:
            `Sequence`: The modified `Sequence` object.
        &#34;&#34;&#34;
        self._cache = cache
        return self

    def initialize_cache(self, cache: Cache) -&gt; Sequence:
        &#34;&#34;&#34;Calling `gcip.core.job.Job.set_cache()` to all jobs within this sequence that haven&#39;t been set the cache before.

        Returns:
            `Sequence`: The modified `Sequence` object.
        &#34;&#34;&#34;
        self._cache_for_initialization = cache
        return self

    def add_tags(self, *tags: str) -&gt; Sequence:
        &#34;&#34;&#34;Calling `gcip.core.job.Job.add_tags()` to all jobs within this sequence.

        Returns:
            `Sequence`: The modified `Sequence` object.
        &#34;&#34;&#34;
        for tag in tags:
            self._tags[tag] = None
        return self

    def initialize_tags(self, *tags: str) -&gt; Sequence:
        &#34;&#34;&#34;Calling `gcip.core.job.Job.add_tags()` to all jobs within this sequence that haven&#39;t been added tags before.

        Returns:
            `Sequence`: The modified `Sequence` object.
        &#34;&#34;&#34;
        for tag in tags:
            self._tags_for_initialization[tag] = None
        return self

    def override_tags(self, *tags: str) -&gt; Sequence:
        &#34;&#34;&#34;Calling `gcip.core.job.Job.add_tags()` to all jobs within this sequence and overriding any previously added tags to that jobs.

        Returns:
            `Sequence`: The modified `Sequence` object.
        &#34;&#34;&#34;
        for tag in tags:
            self._tags_for_replacement[tag] = None
        return self

    def add_artifacts_paths(self, *paths: str) -&gt; Sequence:
        &#34;&#34;&#34;Calling `gcip.core.job.Job.add_artifacts_paths()` to all jobs within this sequence.

        Returns:
            `Sequence`: The modified `Sequence` object.
        &#34;&#34;&#34;
        for path in paths:
            self._artifacts_paths[path] = None
        return self

    def initialize_artifacts_paths(self, *paths: str) -&gt; Sequence:
        &#34;&#34;&#34;Calling `gcip.core.job.Job.add_artifacts_paths()` to all jobs within this sequence that haven&#39;t been added artifacts paths before.

        Returns:
            `Sequence`: The modified `Sequence` object.
        &#34;&#34;&#34;
        for path in paths:
            self._artifacts_paths_for_initialization[path] = None
        return self

    def override_artifacts_paths(self, *paths: str) -&gt; Sequence:
        &#34;&#34;&#34;Calling `gcip.core.job.Job.add_artifacts_paths()` to all jobs within this sequence and overriding any previously added artifacts paths to that jobs.

        Returns:
            `Sequence`: The modified `Sequence` object.
        &#34;&#34;&#34;
        for path in paths:
            self._artifacts_paths_for_replacement[path] = None
        return self

    def append_rules(self, *rules: Rule) -&gt; Sequence:
        &#34;&#34;&#34;Calling `gcip.core.job.Job.append_rules()` to all jobs within this sequence.

        Returns:
            `Sequence`: The modified `Sequence` object.
        &#34;&#34;&#34;
        self._rules_to_append.extend(rules)
        return self

    def prepend_rules(self, *rules: Rule) -&gt; Sequence:
        &#34;&#34;&#34;Calling `gcip.core.job.Job.prepend_rules()` to all jobs within this sequence.

        Returns:
            `Sequence`: The modified `Sequence` object.
        &#34;&#34;&#34;
        self._rules_to_prepend = list(rules) + self._rules_to_prepend
        return self

    def initialize_rules(self, *rules: Rule) -&gt; Sequence:
        &#34;&#34;&#34;Calling `gcip.core.job.Job.append_rules()` to all jobs within this sequence that haven&#39;t been added rules before.

        Returns:
            `Sequence`: The modified `Sequence` object.
        &#34;&#34;&#34;
        self._rules_for_initialization.extend(rules)
        return self

    def override_rules(self, *rules: Rule) -&gt; Sequence:
        &#34;&#34;&#34;Calling `gcip.core.job.Job.override_rules()` to all jobs within this sequence and overriding any previously added rules to that jobs.

        Returns:
            `Sequence`: The modified `Sequence` object.
        &#34;&#34;&#34;
        self._rules_for_replacement.extend(rules)
        return self

    def add_needs(self, *needs: Union[Job, Need]) -&gt; Sequence:
        &#34;&#34;&#34;Calling `gcip.core.job.Job.add_need()` to all jobs within the first stage of this sequence.

        Returns:
            `Sequence`: The modified `Sequence` object.
        &#34;&#34;&#34;
        self._needs.extend(needs)
        return self

    def prepend_scripts(self, *scripts: str) -&gt; Sequence:
        &#34;&#34;&#34;Calling `gcip.core.job.Job.prepend_scripts()` to all jobs within this sequence.

        Returns:
            `Sequence`: The modified `Sequence` object.
        &#34;&#34;&#34;
        self._scripts_to_prepend = list(scripts) + self._scripts_to_prepend
        return self

    def append_scripts(self, *scripts: str) -&gt; Sequence:
        &#34;&#34;&#34;Calling `gcip.core.job.Job.append_scripts()` to all jobs within this sequence.

        Returns:
            `Sequence`: The modified `Sequence` object.
        &#34;&#34;&#34;
        self._scripts_to_append.extend(scripts)
        return self

    def initialize_image(self, image: Union[Image, str]) -&gt; Sequence:
        &#34;&#34;&#34;Calling `gcip.core.job.Job.set_image()` to all jobs within this sequence.

        Returns:
            `Sequence`: The modified `Sequence` object.
        &#34;&#34;&#34;
        if image:
            self._image_for_initialization = image
        return self

    def override_image(self, image: Union[Image, str]) -&gt; Sequence:
        &#34;&#34;&#34;Calling `gcip.core.job.Job.set_image()` to all jobs within this sequence that haven&#39;t been set the image before.

        Returns:
            `Sequence`: The modified `Sequence` object.
        &#34;&#34;&#34;
        if image:
            self._image_for_replacement = image
        return self

    def _get_all_instance_names(self, child: Union[Job, Sequence]) -&gt; Set[str]:
        &#34;&#34;&#34;Return all instance names from the given child.

        That means all combinations of the childs name and namespace within this
        sequence and all parent sequences.
        &#34;&#34;&#34;

        # first get all instance names from parents of this sequence
        own_instance_names: Set[str] = set()
        for parent in self._parents:
            own_instance_names.update(parent._get_all_instance_names(self))

        # second get all instance names of the child within this sequence
        child_instance_names: Set[str] = set()
        child_instance_name: str
        for item in self._children:
            if item[&#34;child&#34;] == child:
                child_name = item[&#34;name&#34;]
                child_namespace = item[&#34;namespace&#34;]
                if child_namespace:
                    if child_name:
                        child_instance_name = f&#34;{child_namespace}-{child_name}&#34;
                    else:
                        child_instance_name = child_namespace
                elif child_name:
                    child_instance_name = child_name
                else:
                    child_instance_name = &#34;&#34;

                # all job names have &#39;-&#39; instead of &#39;_&#39;
                child_instance_names.add(child_instance_name.replace(&#34;_&#34;, &#34;-&#34;))

        # third combine all instance names of this sequences
        # with all instance names of the child
        return_values: Set[str] = set()
        if own_instance_names:
            for child_instance_name in child_instance_names:
                for instance_name in own_instance_names:
                    if child_instance_name:
                        return_values.add(f&#34;{child_instance_name}-{instance_name}&#34;)
                    else:
                        return_values.add(instance_name)
        else:
            return_values = child_instance_names

        return return_values

    @property
    def last_jobs_executed(self) -&gt; List[Job]:
        &#34;&#34;&#34;This property returns all Jobs from the last stage of this sequence.

        This is typically be requested from a job which has setup this sequence as need,
        to determine all actual jobs of this sequence as need.
        &#34;&#34;&#34;
        all_jobs = self.populated_jobs
        stages: Dict[str, None] = {}
        for job in all_jobs:
            # use the keys of dictionary as ordered set
            stages[job.stage] = None

        last_stage = list(stages.keys())[-1]
        last_executed_jobs: List[Job] = list()
        for job in all_jobs:
            if job._stage == last_stage:
                if job._original:
                    last_executed_jobs.append(job._original)
                else:
                    raise AttributeError(&#34;job._original is None, because the job is not a copy of another job&#34;)

        return last_executed_jobs

    @property
    def populated_jobs(self) -&gt; List[Job]:
        &#34;&#34;&#34;Returns a list with populated copies of all nested jobs of this sequence.

        Populated means, that all attributes of a Job which depends on its context are resolved
        to their final values. The context is primarily the sequence within the jobs resides but
        also dependencies to other jobs and sequences. Thus this sequence will apply its own
        configuration, like variables to add, tags to set, etc., to all its jobs and sequences.

        Copies means what it says, that the returned job are not the same job objects, originally
        added to this sequence, but copies of them.

        Nested means, that also jobs from sequences within this sequence, are returned, as well
        as jobs from sequences within sequences within this sequence and so on.

        Returns:
            List[Job]: A list of copies of all nested jobs of this sequence with their final attribute values.
        &#34;&#34;&#34;
        all_jobs: List[Job] = []
        for item in self._children:
            child = item[&#34;child&#34;]
            child_name = item[&#34;name&#34;]
            child_namespace = item[&#34;namespace&#34;]
            if isinstance(child, Sequence):
                for job_copy in child.populated_jobs:
                    job_copy._extend_namespace(child_namespace)
                    job_copy._extend_name(child_name)
                    all_jobs.append(job_copy)
            elif isinstance(child, Job):
                job_copy = child.copy()
                job_copy._extend_namespace(child_namespace)
                job_copy._extend_name(child_name)
                all_jobs.append(job_copy)

        if len(all_jobs) &gt; 0:
            first_job = all_jobs[0]
            first_job.add_needs(*self._needs)
            for job in all_jobs[1:]:
                if job._stage == first_job.stage:
                    job.add_needs(*self._needs)

        for job in all_jobs:

            if self._image_for_initialization and not job._image:
                job.set_image(self._image_for_initialization)
            if self._image_for_replacement:
                job.set_image(self._image_for_replacement)

            if self._variables_for_initialization and not job._variables:
                job._variables = copy.deepcopy(self._variables_for_initialization)
            if self._variables_for_replacement:
                job._variables = copy.deepcopy(self._variables_for_replacement)
            job.add_variables(**copy.deepcopy(self._variables))

            if self._cache_for_initialization and not job._cache:
                job._cache = copy.deepcopy(self._cache_for_initialization)
            job.set_cache(copy.deepcopy(self._cache))

            if self._tags_for_initialization and not job._tags:
                job._tags = copy.deepcopy(self._tags_for_initialization)
            if self._tags_for_replacement:
                job._tags = copy.deepcopy(self._tags_for_replacement)
            job.add_tags(*list(self._tags.keys()))

            if self._artifacts_paths_for_initialization and not job._artifacts_paths:
                job._artifacts_paths = copy.deepcopy(self._artifacts_paths_for_initialization)
            if self._artifacts_paths_for_replacement:
                job._artifacts_paths = copy.deepcopy(self._artifacts_paths_for_replacement)
            job.add_artifacts_paths(*list(self._artifacts_paths.keys()))

            if self._rules_for_initialization and not job._rules:
                job._rules = copy.deepcopy(self._rules_for_initialization)
            if self._rules_for_replacement:
                job._rules = copy.deepcopy(self._rules_for_replacement)
            job.append_rules(*self._rules_to_append)
            job.prepend_rules(*self._rules_to_prepend)

            job.prepend_scripts(*self._scripts_to_prepend)
            job.append_scripts(*self._scripts_to_append)

        return all_jobs</code></pre>
</details>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="gcip.core.pipeline.Pipeline" href="pipeline.html#gcip.core.pipeline.Pipeline">Pipeline</a></li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="gcip.core.sequence.Sequence.last_jobs_executed"><code class="name">var <span class="ident">last_jobs_executed</span> : List[<a title="gcip.core.job.Job" href="job.html#gcip.core.job.Job">Job</a>]</code></dt>
<dd>
<div class="desc"><p>This property returns all Jobs from the last stage of this sequence.</p>
<p>This is typically be requested from a job which has setup this sequence as need,
to determine all actual jobs of this sequence as need.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def last_jobs_executed(self) -&gt; List[Job]:
    &#34;&#34;&#34;This property returns all Jobs from the last stage of this sequence.

    This is typically be requested from a job which has setup this sequence as need,
    to determine all actual jobs of this sequence as need.
    &#34;&#34;&#34;
    all_jobs = self.populated_jobs
    stages: Dict[str, None] = {}
    for job in all_jobs:
        # use the keys of dictionary as ordered set
        stages[job.stage] = None

    last_stage = list(stages.keys())[-1]
    last_executed_jobs: List[Job] = list()
    for job in all_jobs:
        if job._stage == last_stage:
            if job._original:
                last_executed_jobs.append(job._original)
            else:
                raise AttributeError(&#34;job._original is None, because the job is not a copy of another job&#34;)

    return last_executed_jobs</code></pre>
</details>
</dd>
<dt id="gcip.core.sequence.Sequence.populated_jobs"><code class="name">var <span class="ident">populated_jobs</span> : List[<a title="gcip.core.job.Job" href="job.html#gcip.core.job.Job">Job</a>]</code></dt>
<dd>
<div class="desc"><p>Returns a list with populated copies of all nested jobs of this sequence.</p>
<p>Populated means, that all attributes of a Job which depends on its context are resolved
to their final values. The context is primarily the sequence within the jobs resides but
also dependencies to other jobs and sequences. Thus this sequence will apply its own
configuration, like variables to add, tags to set, etc., to all its jobs and sequences.</p>
<p>Copies means what it says, that the returned job are not the same job objects, originally
added to this sequence, but copies of them.</p>
<p>Nested means, that also jobs from sequences within this sequence, are returned, as well
as jobs from sequences within sequences within this sequence and so on.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>List[Job]</code></dt>
<dd>A list of copies of all nested jobs of this sequence with their final attribute values.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def populated_jobs(self) -&gt; List[Job]:
    &#34;&#34;&#34;Returns a list with populated copies of all nested jobs of this sequence.

    Populated means, that all attributes of a Job which depends on its context are resolved
    to their final values. The context is primarily the sequence within the jobs resides but
    also dependencies to other jobs and sequences. Thus this sequence will apply its own
    configuration, like variables to add, tags to set, etc., to all its jobs and sequences.

    Copies means what it says, that the returned job are not the same job objects, originally
    added to this sequence, but copies of them.

    Nested means, that also jobs from sequences within this sequence, are returned, as well
    as jobs from sequences within sequences within this sequence and so on.

    Returns:
        List[Job]: A list of copies of all nested jobs of this sequence with their final attribute values.
    &#34;&#34;&#34;
    all_jobs: List[Job] = []
    for item in self._children:
        child = item[&#34;child&#34;]
        child_name = item[&#34;name&#34;]
        child_namespace = item[&#34;namespace&#34;]
        if isinstance(child, Sequence):
            for job_copy in child.populated_jobs:
                job_copy._extend_namespace(child_namespace)
                job_copy._extend_name(child_name)
                all_jobs.append(job_copy)
        elif isinstance(child, Job):
            job_copy = child.copy()
            job_copy._extend_namespace(child_namespace)
            job_copy._extend_name(child_name)
            all_jobs.append(job_copy)

    if len(all_jobs) &gt; 0:
        first_job = all_jobs[0]
        first_job.add_needs(*self._needs)
        for job in all_jobs[1:]:
            if job._stage == first_job.stage:
                job.add_needs(*self._needs)

    for job in all_jobs:

        if self._image_for_initialization and not job._image:
            job.set_image(self._image_for_initialization)
        if self._image_for_replacement:
            job.set_image(self._image_for_replacement)

        if self._variables_for_initialization and not job._variables:
            job._variables = copy.deepcopy(self._variables_for_initialization)
        if self._variables_for_replacement:
            job._variables = copy.deepcopy(self._variables_for_replacement)
        job.add_variables(**copy.deepcopy(self._variables))

        if self._cache_for_initialization and not job._cache:
            job._cache = copy.deepcopy(self._cache_for_initialization)
        job.set_cache(copy.deepcopy(self._cache))

        if self._tags_for_initialization and not job._tags:
            job._tags = copy.deepcopy(self._tags_for_initialization)
        if self._tags_for_replacement:
            job._tags = copy.deepcopy(self._tags_for_replacement)
        job.add_tags(*list(self._tags.keys()))

        if self._artifacts_paths_for_initialization and not job._artifacts_paths:
            job._artifacts_paths = copy.deepcopy(self._artifacts_paths_for_initialization)
        if self._artifacts_paths_for_replacement:
            job._artifacts_paths = copy.deepcopy(self._artifacts_paths_for_replacement)
        job.add_artifacts_paths(*list(self._artifacts_paths.keys()))

        if self._rules_for_initialization and not job._rules:
            job._rules = copy.deepcopy(self._rules_for_initialization)
        if self._rules_for_replacement:
            job._rules = copy.deepcopy(self._rules_for_replacement)
        job.append_rules(*self._rules_to_append)
        job.prepend_rules(*self._rules_to_prepend)

        job.prepend_scripts(*self._scripts_to_prepend)
        job.append_scripts(*self._scripts_to_append)

    return all_jobs</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="gcip.core.sequence.Sequence.add_artifacts_paths"><code class="name flex">
<span>def <span class="ident">add_artifacts_paths</span></span>(<span>self, *paths: str) ‑> <a title="gcip.core.sequence.Sequence" href="#gcip.core.sequence.Sequence">Sequence</a></span>
</code></dt>
<dd>
<div class="desc"><p>Calling <code><a title="gcip.core.job.Job.add_artifacts_paths" href="job.html#gcip.core.job.Job.add_artifacts_paths">Job.add_artifacts_paths()</a></code> to all jobs within this sequence.</p>
<h2 id="returns">Returns</h2>
<p><code><a title="gcip.core.sequence.Sequence" href="#gcip.core.sequence.Sequence">Sequence</a></code>: The modified <code><a title="gcip.core.sequence.Sequence" href="#gcip.core.sequence.Sequence">Sequence</a></code> object.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_artifacts_paths(self, *paths: str) -&gt; Sequence:
    &#34;&#34;&#34;Calling `gcip.core.job.Job.add_artifacts_paths()` to all jobs within this sequence.

    Returns:
        `Sequence`: The modified `Sequence` object.
    &#34;&#34;&#34;
    for path in paths:
        self._artifacts_paths[path] = None
    return self</code></pre>
</details>
</dd>
<dt id="gcip.core.sequence.Sequence.add_children"><code class="name flex">
<span>def <span class="ident">add_children</span></span>(<span>self, *jobs_or_sequences: Union[Job, <a title="gcip.core.sequence.Sequence" href="#gcip.core.sequence.Sequence">Sequence</a>], namespace: Optional[str] = None, name: Optional[str] = None) ‑> <a title="gcip.core.sequence.Sequence" href="#gcip.core.sequence.Sequence">Sequence</a></span>
</code></dt>
<dd>
<div class="desc"><p>Add <code><a title="gcip.core.job.Job" href="job.html#gcip.core.job.Job">Job</a></code>s or other <code><a title="gcip.core.sequence.Sequence" href="#gcip.core.sequence.Sequence">Sequence</a></code>s to this sequence.</p>
<p>Adding a child creates a copy of that child. You should provide a name or namespace
when adding children, to make them different from other places where they will be used.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>jobs_or_sequences</code></strong> :&ensp;<code>Union[Job, <a title="gcip.core.sequence.Sequence" href="#gcip.core.sequence.Sequence">Sequence</a>]</code></dt>
<dd>One or more jobs or sequences to be added to this sequence.</dd>
<dt><strong><code>namespace</code></strong> :&ensp;<code>Optional[str]</code>, optional</dt>
<dd>Adds a namespaces component to all children added. Defaults to None.</dd>
<dt><strong><code>name</code></strong> :&ensp;<code>Optional[str]</code>, optional</dt>
<dd>Adds a name component to all children added. Defaults to None.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p><code><a title="gcip.core.sequence.Sequence" href="#gcip.core.sequence.Sequence">Sequence</a></code>: The modified <code><a title="gcip.core.sequence.Sequence" href="#gcip.core.sequence.Sequence">Sequence</a></code> object.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_children(
    self,
    *jobs_or_sequences: Union[Job, Sequence],
    namespace: Optional[str] = None,
    name: Optional[str] = None,
) -&gt; Sequence:
    &#34;&#34;&#34;Add `gcip.core.job.Job`s or other `gcip.core.sequence.Sequence`s to this sequence.

    Adding a child creates a copy of that child. You should provide a name or namespace
    when adding children, to make them different from other places where they will be used.

    Args:
        jobs_or_sequences (Union[Job, Sequence]): One or more jobs or sequences to be added to this sequence.
        namespace (Optional[str], optional): Adds a namespaces component to all children added. Defaults to None.
        name (Optional[str], optional): Adds a name component to all children added. Defaults to None.

    Returns:
        `Sequence`: The modified `Sequence` object.
    &#34;&#34;&#34;
    for child in jobs_or_sequences:
        child._add_parent(self)
        self._children.append({&#34;child&#34;: child, &#34;namespace&#34;: namespace, &#34;name&#34;: name})
    return self</code></pre>
</details>
</dd>
<dt id="gcip.core.sequence.Sequence.add_needs"><code class="name flex">
<span>def <span class="ident">add_needs</span></span>(<span>self, *needs: Union[Job, Need]) ‑> <a title="gcip.core.sequence.Sequence" href="#gcip.core.sequence.Sequence">Sequence</a></span>
</code></dt>
<dd>
<div class="desc"><p>Calling <code>gcip.core.job.Job.add_need()</code> to all jobs within the first stage of this sequence.</p>
<h2 id="returns">Returns</h2>
<p><code><a title="gcip.core.sequence.Sequence" href="#gcip.core.sequence.Sequence">Sequence</a></code>: The modified <code><a title="gcip.core.sequence.Sequence" href="#gcip.core.sequence.Sequence">Sequence</a></code> object.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_needs(self, *needs: Union[Job, Need]) -&gt; Sequence:
    &#34;&#34;&#34;Calling `gcip.core.job.Job.add_need()` to all jobs within the first stage of this sequence.

    Returns:
        `Sequence`: The modified `Sequence` object.
    &#34;&#34;&#34;
    self._needs.extend(needs)
    return self</code></pre>
</details>
</dd>
<dt id="gcip.core.sequence.Sequence.add_tags"><code class="name flex">
<span>def <span class="ident">add_tags</span></span>(<span>self, *tags: str) ‑> <a title="gcip.core.sequence.Sequence" href="#gcip.core.sequence.Sequence">Sequence</a></span>
</code></dt>
<dd>
<div class="desc"><p>Calling <code><a title="gcip.core.job.Job.add_tags" href="job.html#gcip.core.job.Job.add_tags">Job.add_tags()</a></code> to all jobs within this sequence.</p>
<h2 id="returns">Returns</h2>
<p><code><a title="gcip.core.sequence.Sequence" href="#gcip.core.sequence.Sequence">Sequence</a></code>: The modified <code><a title="gcip.core.sequence.Sequence" href="#gcip.core.sequence.Sequence">Sequence</a></code> object.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_tags(self, *tags: str) -&gt; Sequence:
    &#34;&#34;&#34;Calling `gcip.core.job.Job.add_tags()` to all jobs within this sequence.

    Returns:
        `Sequence`: The modified `Sequence` object.
    &#34;&#34;&#34;
    for tag in tags:
        self._tags[tag] = None
    return self</code></pre>
</details>
</dd>
<dt id="gcip.core.sequence.Sequence.add_variables"><code class="name flex">
<span>def <span class="ident">add_variables</span></span>(<span>self, **variables: str) ‑> <a title="gcip.core.sequence.Sequence" href="#gcip.core.sequence.Sequence">Sequence</a></span>
</code></dt>
<dd>
<div class="desc"><p>Calling <code><a title="gcip.core.job.Job.add_variables" href="job.html#gcip.core.job.Job.add_variables">Job.add_variables()</a></code> to all jobs within this sequence.</p>
<h2 id="returns">Returns</h2>
<p><code><a title="gcip.core.sequence.Sequence" href="#gcip.core.sequence.Sequence">Sequence</a></code>: The modified <code><a title="gcip.core.sequence.Sequence" href="#gcip.core.sequence.Sequence">Sequence</a></code> object.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_variables(self, **variables: str) -&gt; Sequence:
    &#34;&#34;&#34;Calling `gcip.core.job.Job.add_variables()` to all jobs within this sequence.

    Returns:
        `Sequence`: The modified `Sequence` object.
    &#34;&#34;&#34;
    self._variables.update(variables)
    return self</code></pre>
</details>
</dd>
<dt id="gcip.core.sequence.Sequence.append_rules"><code class="name flex">
<span>def <span class="ident">append_rules</span></span>(<span>self, *rules: Rule) ‑> <a title="gcip.core.sequence.Sequence" href="#gcip.core.sequence.Sequence">Sequence</a></span>
</code></dt>
<dd>
<div class="desc"><p>Calling <code><a title="gcip.core.job.Job.append_rules" href="job.html#gcip.core.job.Job.append_rules">Job.append_rules()</a></code> to all jobs within this sequence.</p>
<h2 id="returns">Returns</h2>
<p><code><a title="gcip.core.sequence.Sequence" href="#gcip.core.sequence.Sequence">Sequence</a></code>: The modified <code><a title="gcip.core.sequence.Sequence" href="#gcip.core.sequence.Sequence">Sequence</a></code> object.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def append_rules(self, *rules: Rule) -&gt; Sequence:
    &#34;&#34;&#34;Calling `gcip.core.job.Job.append_rules()` to all jobs within this sequence.

    Returns:
        `Sequence`: The modified `Sequence` object.
    &#34;&#34;&#34;
    self._rules_to_append.extend(rules)
    return self</code></pre>
</details>
</dd>
<dt id="gcip.core.sequence.Sequence.append_scripts"><code class="name flex">
<span>def <span class="ident">append_scripts</span></span>(<span>self, *scripts: str) ‑> <a title="gcip.core.sequence.Sequence" href="#gcip.core.sequence.Sequence">Sequence</a></span>
</code></dt>
<dd>
<div class="desc"><p>Calling <code><a title="gcip.core.job.Job.append_scripts" href="job.html#gcip.core.job.Job.append_scripts">Job.append_scripts()</a></code> to all jobs within this sequence.</p>
<h2 id="returns">Returns</h2>
<p><code><a title="gcip.core.sequence.Sequence" href="#gcip.core.sequence.Sequence">Sequence</a></code>: The modified <code><a title="gcip.core.sequence.Sequence" href="#gcip.core.sequence.Sequence">Sequence</a></code> object.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def append_scripts(self, *scripts: str) -&gt; Sequence:
    &#34;&#34;&#34;Calling `gcip.core.job.Job.append_scripts()` to all jobs within this sequence.

    Returns:
        `Sequence`: The modified `Sequence` object.
    &#34;&#34;&#34;
    self._scripts_to_append.extend(scripts)
    return self</code></pre>
</details>
</dd>
<dt id="gcip.core.sequence.Sequence.initialize_artifacts_paths"><code class="name flex">
<span>def <span class="ident">initialize_artifacts_paths</span></span>(<span>self, *paths: str) ‑> <a title="gcip.core.sequence.Sequence" href="#gcip.core.sequence.Sequence">Sequence</a></span>
</code></dt>
<dd>
<div class="desc"><p>Calling <code><a title="gcip.core.job.Job.add_artifacts_paths" href="job.html#gcip.core.job.Job.add_artifacts_paths">Job.add_artifacts_paths()</a></code> to all jobs within this sequence that haven't been added artifacts paths before.</p>
<h2 id="returns">Returns</h2>
<p><code><a title="gcip.core.sequence.Sequence" href="#gcip.core.sequence.Sequence">Sequence</a></code>: The modified <code><a title="gcip.core.sequence.Sequence" href="#gcip.core.sequence.Sequence">Sequence</a></code> object.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def initialize_artifacts_paths(self, *paths: str) -&gt; Sequence:
    &#34;&#34;&#34;Calling `gcip.core.job.Job.add_artifacts_paths()` to all jobs within this sequence that haven&#39;t been added artifacts paths before.

    Returns:
        `Sequence`: The modified `Sequence` object.
    &#34;&#34;&#34;
    for path in paths:
        self._artifacts_paths_for_initialization[path] = None
    return self</code></pre>
</details>
</dd>
<dt id="gcip.core.sequence.Sequence.initialize_cache"><code class="name flex">
<span>def <span class="ident">initialize_cache</span></span>(<span>self, cache: Cache) ‑> <a title="gcip.core.sequence.Sequence" href="#gcip.core.sequence.Sequence">Sequence</a></span>
</code></dt>
<dd>
<div class="desc"><p>Calling <code><a title="gcip.core.job.Job.set_cache" href="job.html#gcip.core.job.Job.set_cache">Job.set_cache()</a></code> to all jobs within this sequence that haven't been set the cache before.</p>
<h2 id="returns">Returns</h2>
<p><code><a title="gcip.core.sequence.Sequence" href="#gcip.core.sequence.Sequence">Sequence</a></code>: The modified <code><a title="gcip.core.sequence.Sequence" href="#gcip.core.sequence.Sequence">Sequence</a></code> object.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def initialize_cache(self, cache: Cache) -&gt; Sequence:
    &#34;&#34;&#34;Calling `gcip.core.job.Job.set_cache()` to all jobs within this sequence that haven&#39;t been set the cache before.

    Returns:
        `Sequence`: The modified `Sequence` object.
    &#34;&#34;&#34;
    self._cache_for_initialization = cache
    return self</code></pre>
</details>
</dd>
<dt id="gcip.core.sequence.Sequence.initialize_image"><code class="name flex">
<span>def <span class="ident">initialize_image</span></span>(<span>self, image: Union[Image, str]) ‑> <a title="gcip.core.sequence.Sequence" href="#gcip.core.sequence.Sequence">Sequence</a></span>
</code></dt>
<dd>
<div class="desc"><p>Calling <code><a title="gcip.core.job.Job.set_image" href="job.html#gcip.core.job.Job.set_image">Job.set_image()</a></code> to all jobs within this sequence.</p>
<h2 id="returns">Returns</h2>
<p><code><a title="gcip.core.sequence.Sequence" href="#gcip.core.sequence.Sequence">Sequence</a></code>: The modified <code><a title="gcip.core.sequence.Sequence" href="#gcip.core.sequence.Sequence">Sequence</a></code> object.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def initialize_image(self, image: Union[Image, str]) -&gt; Sequence:
    &#34;&#34;&#34;Calling `gcip.core.job.Job.set_image()` to all jobs within this sequence.

    Returns:
        `Sequence`: The modified `Sequence` object.
    &#34;&#34;&#34;
    if image:
        self._image_for_initialization = image
    return self</code></pre>
</details>
</dd>
<dt id="gcip.core.sequence.Sequence.initialize_rules"><code class="name flex">
<span>def <span class="ident">initialize_rules</span></span>(<span>self, *rules: Rule) ‑> <a title="gcip.core.sequence.Sequence" href="#gcip.core.sequence.Sequence">Sequence</a></span>
</code></dt>
<dd>
<div class="desc"><p>Calling <code><a title="gcip.core.job.Job.append_rules" href="job.html#gcip.core.job.Job.append_rules">Job.append_rules()</a></code> to all jobs within this sequence that haven't been added rules before.</p>
<h2 id="returns">Returns</h2>
<p><code><a title="gcip.core.sequence.Sequence" href="#gcip.core.sequence.Sequence">Sequence</a></code>: The modified <code><a title="gcip.core.sequence.Sequence" href="#gcip.core.sequence.Sequence">Sequence</a></code> object.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def initialize_rules(self, *rules: Rule) -&gt; Sequence:
    &#34;&#34;&#34;Calling `gcip.core.job.Job.append_rules()` to all jobs within this sequence that haven&#39;t been added rules before.

    Returns:
        `Sequence`: The modified `Sequence` object.
    &#34;&#34;&#34;
    self._rules_for_initialization.extend(rules)
    return self</code></pre>
</details>
</dd>
<dt id="gcip.core.sequence.Sequence.initialize_tags"><code class="name flex">
<span>def <span class="ident">initialize_tags</span></span>(<span>self, *tags: str) ‑> <a title="gcip.core.sequence.Sequence" href="#gcip.core.sequence.Sequence">Sequence</a></span>
</code></dt>
<dd>
<div class="desc"><p>Calling <code><a title="gcip.core.job.Job.add_tags" href="job.html#gcip.core.job.Job.add_tags">Job.add_tags()</a></code> to all jobs within this sequence that haven't been added tags before.</p>
<h2 id="returns">Returns</h2>
<p><code><a title="gcip.core.sequence.Sequence" href="#gcip.core.sequence.Sequence">Sequence</a></code>: The modified <code><a title="gcip.core.sequence.Sequence" href="#gcip.core.sequence.Sequence">Sequence</a></code> object.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def initialize_tags(self, *tags: str) -&gt; Sequence:
    &#34;&#34;&#34;Calling `gcip.core.job.Job.add_tags()` to all jobs within this sequence that haven&#39;t been added tags before.

    Returns:
        `Sequence`: The modified `Sequence` object.
    &#34;&#34;&#34;
    for tag in tags:
        self._tags_for_initialization[tag] = None
    return self</code></pre>
</details>
</dd>
<dt id="gcip.core.sequence.Sequence.initialize_variables"><code class="name flex">
<span>def <span class="ident">initialize_variables</span></span>(<span>self, **variables: str) ‑> <a title="gcip.core.sequence.Sequence" href="#gcip.core.sequence.Sequence">Sequence</a></span>
</code></dt>
<dd>
<div class="desc"><p>Calling <code><a title="gcip.core.job.Job.add_variables" href="job.html#gcip.core.job.Job.add_variables">Job.add_variables()</a></code> to all jobs within this sequence that haven't been added variables before.</p>
<h2 id="returns">Returns</h2>
<p><code><a title="gcip.core.sequence.Sequence" href="#gcip.core.sequence.Sequence">Sequence</a></code>: The modified <code><a title="gcip.core.sequence.Sequence" href="#gcip.core.sequence.Sequence">Sequence</a></code> object.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def initialize_variables(self, **variables: str) -&gt; Sequence:
    &#34;&#34;&#34;Calling `gcip.core.job.Job.add_variables()` to all jobs within this sequence that haven&#39;t been added variables before.

    Returns:
        `Sequence`: The modified `Sequence` object.
    &#34;&#34;&#34;
    self._variables_for_initialization.update(variables)
    return self</code></pre>
</details>
</dd>
<dt id="gcip.core.sequence.Sequence.override_artifacts_paths"><code class="name flex">
<span>def <span class="ident">override_artifacts_paths</span></span>(<span>self, *paths: str) ‑> <a title="gcip.core.sequence.Sequence" href="#gcip.core.sequence.Sequence">Sequence</a></span>
</code></dt>
<dd>
<div class="desc"><p>Calling <code><a title="gcip.core.job.Job.add_artifacts_paths" href="job.html#gcip.core.job.Job.add_artifacts_paths">Job.add_artifacts_paths()</a></code> to all jobs within this sequence and overriding any previously added artifacts paths to that jobs.</p>
<h2 id="returns">Returns</h2>
<p><code><a title="gcip.core.sequence.Sequence" href="#gcip.core.sequence.Sequence">Sequence</a></code>: The modified <code><a title="gcip.core.sequence.Sequence" href="#gcip.core.sequence.Sequence">Sequence</a></code> object.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def override_artifacts_paths(self, *paths: str) -&gt; Sequence:
    &#34;&#34;&#34;Calling `gcip.core.job.Job.add_artifacts_paths()` to all jobs within this sequence and overriding any previously added artifacts paths to that jobs.

    Returns:
        `Sequence`: The modified `Sequence` object.
    &#34;&#34;&#34;
    for path in paths:
        self._artifacts_paths_for_replacement[path] = None
    return self</code></pre>
</details>
</dd>
<dt id="gcip.core.sequence.Sequence.override_image"><code class="name flex">
<span>def <span class="ident">override_image</span></span>(<span>self, image: Union[Image, str]) ‑> <a title="gcip.core.sequence.Sequence" href="#gcip.core.sequence.Sequence">Sequence</a></span>
</code></dt>
<dd>
<div class="desc"><p>Calling <code><a title="gcip.core.job.Job.set_image" href="job.html#gcip.core.job.Job.set_image">Job.set_image()</a></code> to all jobs within this sequence that haven't been set the image before.</p>
<h2 id="returns">Returns</h2>
<p><code><a title="gcip.core.sequence.Sequence" href="#gcip.core.sequence.Sequence">Sequence</a></code>: The modified <code><a title="gcip.core.sequence.Sequence" href="#gcip.core.sequence.Sequence">Sequence</a></code> object.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def override_image(self, image: Union[Image, str]) -&gt; Sequence:
    &#34;&#34;&#34;Calling `gcip.core.job.Job.set_image()` to all jobs within this sequence that haven&#39;t been set the image before.

    Returns:
        `Sequence`: The modified `Sequence` object.
    &#34;&#34;&#34;
    if image:
        self._image_for_replacement = image
    return self</code></pre>
</details>
</dd>
<dt id="gcip.core.sequence.Sequence.override_rules"><code class="name flex">
<span>def <span class="ident">override_rules</span></span>(<span>self, *rules: Rule) ‑> <a title="gcip.core.sequence.Sequence" href="#gcip.core.sequence.Sequence">Sequence</a></span>
</code></dt>
<dd>
<div class="desc"><p>Calling <code>gcip.core.job.Job.override_rules()</code> to all jobs within this sequence and overriding any previously added rules to that jobs.</p>
<h2 id="returns">Returns</h2>
<p><code><a title="gcip.core.sequence.Sequence" href="#gcip.core.sequence.Sequence">Sequence</a></code>: The modified <code><a title="gcip.core.sequence.Sequence" href="#gcip.core.sequence.Sequence">Sequence</a></code> object.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def override_rules(self, *rules: Rule) -&gt; Sequence:
    &#34;&#34;&#34;Calling `gcip.core.job.Job.override_rules()` to all jobs within this sequence and overriding any previously added rules to that jobs.

    Returns:
        `Sequence`: The modified `Sequence` object.
    &#34;&#34;&#34;
    self._rules_for_replacement.extend(rules)
    return self</code></pre>
</details>
</dd>
<dt id="gcip.core.sequence.Sequence.override_tags"><code class="name flex">
<span>def <span class="ident">override_tags</span></span>(<span>self, *tags: str) ‑> <a title="gcip.core.sequence.Sequence" href="#gcip.core.sequence.Sequence">Sequence</a></span>
</code></dt>
<dd>
<div class="desc"><p>Calling <code><a title="gcip.core.job.Job.add_tags" href="job.html#gcip.core.job.Job.add_tags">Job.add_tags()</a></code> to all jobs within this sequence and overriding any previously added tags to that jobs.</p>
<h2 id="returns">Returns</h2>
<p><code><a title="gcip.core.sequence.Sequence" href="#gcip.core.sequence.Sequence">Sequence</a></code>: The modified <code><a title="gcip.core.sequence.Sequence" href="#gcip.core.sequence.Sequence">Sequence</a></code> object.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def override_tags(self, *tags: str) -&gt; Sequence:
    &#34;&#34;&#34;Calling `gcip.core.job.Job.add_tags()` to all jobs within this sequence and overriding any previously added tags to that jobs.

    Returns:
        `Sequence`: The modified `Sequence` object.
    &#34;&#34;&#34;
    for tag in tags:
        self._tags_for_replacement[tag] = None
    return self</code></pre>
</details>
</dd>
<dt id="gcip.core.sequence.Sequence.override_variables"><code class="name flex">
<span>def <span class="ident">override_variables</span></span>(<span>self, **variables: str) ‑> <a title="gcip.core.sequence.Sequence" href="#gcip.core.sequence.Sequence">Sequence</a></span>
</code></dt>
<dd>
<div class="desc"><p>Calling <code><a title="gcip.core.job.Job.add_variables" href="job.html#gcip.core.job.Job.add_variables">Job.add_variables()</a></code> to all jobs within this sequence and overriding any previously added variables to that jobs.</p>
<h2 id="returns">Returns</h2>
<p><code><a title="gcip.core.sequence.Sequence" href="#gcip.core.sequence.Sequence">Sequence</a></code>: The modified <code><a title="gcip.core.sequence.Sequence" href="#gcip.core.sequence.Sequence">Sequence</a></code> object.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def override_variables(self, **variables: str) -&gt; Sequence:
    &#34;&#34;&#34;Calling `gcip.core.job.Job.add_variables()` to all jobs within this sequence and overriding any previously added variables to that jobs.

    Returns:
        `Sequence`: The modified `Sequence` object.
    &#34;&#34;&#34;
    self._variables_for_replacement.update(variables)
    return self</code></pre>
</details>
</dd>
<dt id="gcip.core.sequence.Sequence.prepend_rules"><code class="name flex">
<span>def <span class="ident">prepend_rules</span></span>(<span>self, *rules: Rule) ‑> <a title="gcip.core.sequence.Sequence" href="#gcip.core.sequence.Sequence">Sequence</a></span>
</code></dt>
<dd>
<div class="desc"><p>Calling <code><a title="gcip.core.job.Job.prepend_rules" href="job.html#gcip.core.job.Job.prepend_rules">Job.prepend_rules()</a></code> to all jobs within this sequence.</p>
<h2 id="returns">Returns</h2>
<p><code><a title="gcip.core.sequence.Sequence" href="#gcip.core.sequence.Sequence">Sequence</a></code>: The modified <code><a title="gcip.core.sequence.Sequence" href="#gcip.core.sequence.Sequence">Sequence</a></code> object.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def prepend_rules(self, *rules: Rule) -&gt; Sequence:
    &#34;&#34;&#34;Calling `gcip.core.job.Job.prepend_rules()` to all jobs within this sequence.

    Returns:
        `Sequence`: The modified `Sequence` object.
    &#34;&#34;&#34;
    self._rules_to_prepend = list(rules) + self._rules_to_prepend
    return self</code></pre>
</details>
</dd>
<dt id="gcip.core.sequence.Sequence.prepend_scripts"><code class="name flex">
<span>def <span class="ident">prepend_scripts</span></span>(<span>self, *scripts: str) ‑> <a title="gcip.core.sequence.Sequence" href="#gcip.core.sequence.Sequence">Sequence</a></span>
</code></dt>
<dd>
<div class="desc"><p>Calling <code><a title="gcip.core.job.Job.prepend_scripts" href="job.html#gcip.core.job.Job.prepend_scripts">Job.prepend_scripts()</a></code> to all jobs within this sequence.</p>
<h2 id="returns">Returns</h2>
<p><code><a title="gcip.core.sequence.Sequence" href="#gcip.core.sequence.Sequence">Sequence</a></code>: The modified <code><a title="gcip.core.sequence.Sequence" href="#gcip.core.sequence.Sequence">Sequence</a></code> object.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def prepend_scripts(self, *scripts: str) -&gt; Sequence:
    &#34;&#34;&#34;Calling `gcip.core.job.Job.prepend_scripts()` to all jobs within this sequence.

    Returns:
        `Sequence`: The modified `Sequence` object.
    &#34;&#34;&#34;
    self._scripts_to_prepend = list(scripts) + self._scripts_to_prepend
    return self</code></pre>
</details>
</dd>
<dt id="gcip.core.sequence.Sequence.set_cache"><code class="name flex">
<span>def <span class="ident">set_cache</span></span>(<span>self, cache: Cache) ‑> <a title="gcip.core.sequence.Sequence" href="#gcip.core.sequence.Sequence">Sequence</a></span>
</code></dt>
<dd>
<div class="desc"><p>Calling <code><a title="gcip.core.job.Job.set_cache" href="job.html#gcip.core.job.Job.set_cache">Job.set_cache()</a></code> to all jobs within this sequence.</p>
<h2 id="returns">Returns</h2>
<p><code><a title="gcip.core.sequence.Sequence" href="#gcip.core.sequence.Sequence">Sequence</a></code>: The modified <code><a title="gcip.core.sequence.Sequence" href="#gcip.core.sequence.Sequence">Sequence</a></code> object.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_cache(self, cache: Cache) -&gt; Sequence:
    &#34;&#34;&#34;Calling `gcip.core.job.Job.set_cache()` to all jobs within this sequence.

    Returns:
        `Sequence`: The modified `Sequence` object.
    &#34;&#34;&#34;
    self._cache = cache
    return self</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="gcip.core" href="index.html">gcip.core</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="gcip.core.sequence.ChildDict" href="#gcip.core.sequence.ChildDict">ChildDict</a></code></h4>
<ul class="">
<li><code><a title="gcip.core.sequence.ChildDict.child" href="#gcip.core.sequence.ChildDict.child">child</a></code></li>
<li><code><a title="gcip.core.sequence.ChildDict.name" href="#gcip.core.sequence.ChildDict.name">name</a></code></li>
<li><code><a title="gcip.core.sequence.ChildDict.namespace" href="#gcip.core.sequence.ChildDict.namespace">namespace</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="gcip.core.sequence.Sequence" href="#gcip.core.sequence.Sequence">Sequence</a></code></h4>
<ul class="">
<li><code><a title="gcip.core.sequence.Sequence.add_artifacts_paths" href="#gcip.core.sequence.Sequence.add_artifacts_paths">add_artifacts_paths</a></code></li>
<li><code><a title="gcip.core.sequence.Sequence.add_children" href="#gcip.core.sequence.Sequence.add_children">add_children</a></code></li>
<li><code><a title="gcip.core.sequence.Sequence.add_needs" href="#gcip.core.sequence.Sequence.add_needs">add_needs</a></code></li>
<li><code><a title="gcip.core.sequence.Sequence.add_tags" href="#gcip.core.sequence.Sequence.add_tags">add_tags</a></code></li>
<li><code><a title="gcip.core.sequence.Sequence.add_variables" href="#gcip.core.sequence.Sequence.add_variables">add_variables</a></code></li>
<li><code><a title="gcip.core.sequence.Sequence.append_rules" href="#gcip.core.sequence.Sequence.append_rules">append_rules</a></code></li>
<li><code><a title="gcip.core.sequence.Sequence.append_scripts" href="#gcip.core.sequence.Sequence.append_scripts">append_scripts</a></code></li>
<li><code><a title="gcip.core.sequence.Sequence.initialize_artifacts_paths" href="#gcip.core.sequence.Sequence.initialize_artifacts_paths">initialize_artifacts_paths</a></code></li>
<li><code><a title="gcip.core.sequence.Sequence.initialize_cache" href="#gcip.core.sequence.Sequence.initialize_cache">initialize_cache</a></code></li>
<li><code><a title="gcip.core.sequence.Sequence.initialize_image" href="#gcip.core.sequence.Sequence.initialize_image">initialize_image</a></code></li>
<li><code><a title="gcip.core.sequence.Sequence.initialize_rules" href="#gcip.core.sequence.Sequence.initialize_rules">initialize_rules</a></code></li>
<li><code><a title="gcip.core.sequence.Sequence.initialize_tags" href="#gcip.core.sequence.Sequence.initialize_tags">initialize_tags</a></code></li>
<li><code><a title="gcip.core.sequence.Sequence.initialize_variables" href="#gcip.core.sequence.Sequence.initialize_variables">initialize_variables</a></code></li>
<li><code><a title="gcip.core.sequence.Sequence.last_jobs_executed" href="#gcip.core.sequence.Sequence.last_jobs_executed">last_jobs_executed</a></code></li>
<li><code><a title="gcip.core.sequence.Sequence.override_artifacts_paths" href="#gcip.core.sequence.Sequence.override_artifacts_paths">override_artifacts_paths</a></code></li>
<li><code><a title="gcip.core.sequence.Sequence.override_image" href="#gcip.core.sequence.Sequence.override_image">override_image</a></code></li>
<li><code><a title="gcip.core.sequence.Sequence.override_rules" href="#gcip.core.sequence.Sequence.override_rules">override_rules</a></code></li>
<li><code><a title="gcip.core.sequence.Sequence.override_tags" href="#gcip.core.sequence.Sequence.override_tags">override_tags</a></code></li>
<li><code><a title="gcip.core.sequence.Sequence.override_variables" href="#gcip.core.sequence.Sequence.override_variables">override_variables</a></code></li>
<li><code><a title="gcip.core.sequence.Sequence.populated_jobs" href="#gcip.core.sequence.Sequence.populated_jobs">populated_jobs</a></code></li>
<li><code><a title="gcip.core.sequence.Sequence.prepend_rules" href="#gcip.core.sequence.Sequence.prepend_rules">prepend_rules</a></code></li>
<li><code><a title="gcip.core.sequence.Sequence.prepend_scripts" href="#gcip.core.sequence.Sequence.prepend_scripts">prepend_scripts</a></code></li>
<li><code><a title="gcip.core.sequence.Sequence.set_cache" href="#gcip.core.sequence.Sequence.set_cache">set_cache</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.2</a>.</p>
</footer>
</body>
</html>