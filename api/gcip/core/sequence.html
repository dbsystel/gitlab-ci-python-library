<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2" />
<title>gcip.core.sequence API documentation</title>
<meta name="description" content="A Sequence collects multiple `gcip.core.job.Job`s and/or other `Sequence`s into a group â€¦" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>gcip.core.sequence</code></h1>
</header>
<section id="section-intro">
<p>A Sequence collects multiple <code><a title="gcip.core.job.Job" href="job.html#gcip.core.job.Job">Job</a></code>s and/or other <code><a title="gcip.core.sequence.Sequence" href="#gcip.core.sequence.Sequence">Sequence</a></code>s into a group.</p>
<p>This concept is no official representation of a Gitlab CI keyword. But it is such a powerful
extension of the Gitlab CI core funtionality and an essential building block of the gcip, that
it is conained in the <code><a title="gcip.core" href="index.html">gcip.core</a></code> module.</p>
<p>A Sequence offers a mostly similar interface like <code><a title="gcip.core.job.Job" href="job.html#gcip.core.job.Job">Job</a></code>s that allows to modify
all Jobs and child Sequences contained into that parent Sequence. For example: Instad of calling
<code>add_tag()</code> on a dozens of Jobs you can call <code>add_tag()</code> on the sequence that contain those Jobs.
The tag will then be applied to all Jobs in that Sequence and recursively to all Jobs within child
Sequenes of that Sequence.</p>
<p>Sequences must be added to a <code><a title="gcip.core.pipeline.Pipeline" href="pipeline.html#gcip.core.pipeline.Pipeline">Pipeline</a></code>, either directly or as part of other Sequences.
That means Sequences are not meant to be a throw away configuration container for a bunch ob Jobs.
This is because adding a Job to a Sequence creates a copy of that Job, which will be inderectly added to
the <code>Pipeline</code> by that Sequence. Not adding that Sequence to a Pipeline means also not adding its Jobs
to the Pipeline. If other parts of the Pipeline have dependencies to those Jobs, they will be broken.</p>
<p>As said before, adding a Job to a Sequence creates copies of that Job. To void conflicts between Jobs,
you should set <code>name</code> and/or <code>namespace</code> when adding the job (or child sequence). The sequence will add
the <code>name</code> / <code>namespace</code> to the ones of the Job, when rendering the pipeline. If you do not set those
identifiers, or you set equal name/namespaces for jobs and sequences, you provoke having two or more
jobs having the same name in the pipeline. The gcip will raise a ValueError, to avoid unexpected
pipeline behavior. You can read more information in the chapter "Namespaces allow reuse of jobs
and sequences" of the user documantation.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;A Sequence collects multiple `gcip.core.job.Job`s and/or other `Sequence`s into a group.

This concept is no official representation of a Gitlab CI keyword. But it is such a powerful
extension of the Gitlab CI core funtionality and an essential building block of the gcip, that
it is conained in the `gcip.core` module.

A Sequence offers a mostly similar interface like `gcip.core.job.Job`s that allows to modify
all Jobs and child Sequences contained into that parent Sequence. For example: Instad of calling
`add_tag()` on a dozens of Jobs you can call `add_tag()` on the sequence that contain those Jobs.
The tag will then be applied to all Jobs in that Sequence and recursively to all Jobs within child
Sequenes of that Sequence.

Sequences must be added to a `gcip.core.pipeline.Pipeline`, either directly or as part of other Sequences.
That means Sequences are not meant to be a throw away configuration container for a bunch ob Jobs.
This is because adding a Job to a Sequence creates a copy of that Job, which will be inderectly added to
the `Pipeline` by that Sequence. Not adding that Sequence to a Pipeline means also not adding its Jobs
to the Pipeline. If other parts of the Pipeline have dependencies to those Jobs, they will be broken.

As said before, adding a Job to a Sequence creates copies of that Job. To void conflicts between Jobs,
you should set `name` and/or `namespace` when adding the job (or child sequence). The sequence will add
the `name` / `namespace` to the ones of the Job, when rendering the pipeline. If you do not set those
identifiers, or you set equal name/namespaces for jobs and sequences, you provoke having two or more
jobs having the same name in the pipeline. The gcip will raise a ValueError, to avoid unexpected
pipeline behavior. You can read more information in the chapter &#34;Namespaces allow reuse of jobs
and sequences&#34; of the user documantation.
&#34;&#34;&#34;
from __future__ import annotations

import copy
from typing import (
    Set,
    Dict,
    List,
    Union,
    Optional,
    TypedDict,
)

from . import OrderedSetType
from .job import Job
from .need import Need
from .rule import Rule
from .cache import Cache
from .image import Image

__author__ = &#34;Thomas Steinbach&#34;
__copyright__ = &#34;Copyright 2020 DB Systel GmbH&#34;
__credits__ = [&#34;Thomas Steinbach&#34;, &#34;Daniel von EÃŸen&#34;]
# SPDX-License-Identifier: Apache-2.0
__license__ = &#34;Apache-2.0&#34;
__maintainer__ = &#34;Thomas Steinbach&#34;
__email__ = &#34;thomas.t.steinbach@deutschebahn.com&#34;


class ChildDict(TypedDict):
    &#34;&#34;&#34;This data structure is supposed to store one child of a `Sequence` with all required information about that child.&#34;&#34;&#34;

    child: Union[Job, Sequence]
    &#34;&#34;&#34;The child to store - a `gcip.core.job.Job` or `Sequence`.&#34;&#34;&#34;
    namespace: Optional[str]
    &#34;&#34;&#34;The namespace with whom the `child` was added to the `Sequence`.&#34;&#34;&#34;
    name: Optional[str]
    &#34;&#34;&#34;The name with whom the `child` was added to the `Sequence`.&#34;&#34;&#34;


class Sequence:
    &#34;&#34;&#34;A Sequence collects multiple `gcip.core.job.Job`s and/or other `Sequence`s into a group.&#34;&#34;&#34;

    def __init__(self) -&gt; None:
        super().__init__()
        self._children: List[ChildDict] = list()
        self._image_for_initialization: Optional[Union[Image, str]] = None
        self._image_for_replacement: Optional[Union[Image, str]] = None
        self._variables: Dict[str, str] = {}
        self._variables_for_initialization: Dict[str, str] = {}
        self._variables_for_replacement: Dict[str, str] = {}
        self._tags: OrderedSetType = {}
        self._tags_for_initialization: OrderedSetType = {}
        self._tags_for_replacement: OrderedSetType = {}
        self._artifacts_paths: OrderedSetType = {}
        self._cache: Optional[Cache] = None
        self._cache_for_initialization: Optional[Cache] = None
        self._scripts_to_prepend: List[str] = []
        self._scripts_to_append: List[str] = []
        self._rules_to_append: List[Rule] = []
        self._rules_to_prepend: List[Rule] = []
        self._rules_for_initialization: List[Rule] = []
        self._rules_for_replacement: List[Rule] = []
        self._needs: List[Union[Job, Need]] = []
        self._parents: List[Sequence] = list()

    def _add_parent(self, parent: Sequence) -&gt; None:
        self._parents.append(parent)

    def add_children(
        self,
        *jobs_or_sequences: Union[Job, Sequence],
        namespace: Optional[str] = None,
        name: Optional[str] = None,
    ) -&gt; Sequence:
        for child in jobs_or_sequences:
            child._add_parent(self)
            self._children.append({&#34;child&#34;: child, &#34;namespace&#34;: namespace, &#34;name&#34;: name})
        return self

    def add_variables(self, **variables: str) -&gt; Sequence:
        self._variables.update(variables)
        return self

    def initialize_variables(self, **variables: str) -&gt; Sequence:
        &#34;&#34;&#34;
        Works like :meth:`initialize_tags` but for variales.

        Args:
            variables (str): A keyword argument list which key-value-pairs will be applied as variable-value-pairs
                             to all downstream :class:`Job` s without variables already set.
        &#34;&#34;&#34;
        self._variables_for_initialization.update(variables)
        return self

    def override_variables(self, **variables: str) -&gt; Sequence:
        &#34;&#34;&#34;
        Works like :meth:`override_tags` but for variables.

        Args:
            variables (str): A keyword argument list which key-value-pairs will be set as variable-value-pairs
                             to all downstream :class:`Job` s.
        &#34;&#34;&#34;
        self._variables_for_replacement.update(variables)
        return self

    def set_cache(self, cache: Cache) -&gt; Sequence:
        &#34;&#34;&#34;Sets the cache for the corresponding Sequence.
        This will override any previously set chaches on this sequence or child sequences/jobs.

        Args:
            cache (Cache): Cache to use for the Sequence and its Jobs.

        Returns:
            Sequence: Returns the modified Sequence object.
        &#34;&#34;&#34;
        self._cache = cache
        return self

    def initialize_cache(self, cache: Cache) -&gt; Sequence:
        &#34;&#34;&#34;Sets the cache of child sequences/jobs only  if not set before.

        Args:
            cache (Cache): Cache to use for the Sequence and its Jobs.

        Returns:
            Sequence: Returns the modified Sequence object.
        &#34;&#34;&#34;
        self._cache_for_initialization = cache
        return self

    def add_tags(self, *tags: str) -&gt; Sequence:
        for tag in tags:
            self._tags[tag] = None
        return self

    def initialize_tags(self, *tags: str) -&gt; Sequence:
        &#34;&#34;&#34;
        Adds tags to downstream :class:`Job` s only if they haven&#39;t tags added yet.

        :meth:`initialize_tags` would be extended by :meth:`add_tags` and overridden
        by :meth:`override_tags` if one of the other methods is called too.

        Args:
            tags (str): One or more strings that will be applied to :class:`Job` s with empty tag list.
        &#34;&#34;&#34;
        for tag in tags:
            self._tags_for_initialization[tag] = None
        return self

    def override_tags(self, *tags: str) -&gt; Sequence:
        &#34;&#34;&#34;
        Will replace all tags from downstream :class:`Job` s.

        :meth:`override_tags` will also override tags set by :meth:`initialize_tags`
        but be extended by :meth:`add_tags` when one of the other methods is called too.

        Args:
            tags (str): One or more strings that will be set as tags to all downstream :class:`Job` s.
        &#34;&#34;&#34;
        for tag in tags:
            self._tags_for_replacement[tag] = None
        return self

    def add_artifacts_paths(self, *paths: str) -&gt; Sequence:
        for path in paths:
            self._artifacts_paths[path] = None
        return self

    def append_rules(self, *rules: Rule) -&gt; Sequence:
        self._rules_to_append.extend(rules)
        return self

    def prepend_rules(self, *rules: Rule) -&gt; Sequence:
        self._rules_to_prepend = list(rules) + self._rules_to_prepend
        return self

    def initialize_rules(self, *rules: Rule) -&gt; Sequence:
        &#34;&#34;&#34;
        Works like :meth:`initialize_tags` but for rules.

        Args:
            rules (Rule): A list of :class:`Rule` s that will be applied to :class:`Job` s with empty rules list.
        &#34;&#34;&#34;
        self._rules_for_initialization.extend(rules)
        return self

    def override_rules(self, *rules: Rule) -&gt; Sequence:
        &#34;&#34;&#34;
        Works like :meth:`override_tags` but for rules.

        Args:
            rules (Rule): A list of :class:`Rule` s that will be replace all downstream :class:`Job` s rules.
        &#34;&#34;&#34;
        self._rules_for_replacement.extend(rules)
        return self

    def add_needs(self, *needs: Union[Job, Need]) -&gt; Sequence:
        &#34;&#34;&#34;
        Only the first job of the sequence get the ``need`` appended to, as well as all following jobs with
        the same stage.
        &#34;&#34;&#34;
        self._needs.extend(needs)
        return self

    def prepend_scripts(self, *scripts: str) -&gt; Sequence:
        self._scripts_to_prepend = list(scripts) + self._scripts_to_prepend
        return self

    def append_scripts(self, *scripts: str) -&gt; Sequence:
        self._scripts_to_append.extend(scripts)
        return self

    def initialize_image(self, image: Union[Image, str]) -&gt; Sequence:
        &#34;&#34;&#34;Initializes given `image` to all downstream `Job`s which do not have
        an `image` set.

        Args:
            image (Union[Image, str]): The image to set to all downstream :class:`Job`&#39;s.

        Returns:
            Sequence: Modified `sequence` object.
        &#34;&#34;&#34;
        if image:
            self._image_for_initialization = image
        return self

    def override_image(self, image: Union[Image, str]) -&gt; Sequence:
        &#34;&#34;&#34;Initializes and override&#39;s `image` to all downstream `Job`s.
        In consequence, all downstream `Job`s will be started with `image`.

        Args:
            image (str): The image to set for all downstream :class:`Job`&#39;s.

        Returns:
            Sequence: Modified `sequence` object.
        &#34;&#34;&#34;
        if image:
            self._image_for_replacement = image
        return self

    def _get_all_instance_names(self, child: Union[Job, Sequence]) -&gt; Set[str]:
        instance_names: Set[str] = set()
        for parent in self._parents:
            instance_names.update(parent._get_all_instance_names(self))

        child_instance_names: Set[str] = set()
        child_instance_name: str
        for item in self._children:
            if item[&#34;child&#34;] == child:
                if item[&#34;namespace&#34;] is not None:
                    if item[&#34;name&#34;]:
                        child_instance_name = f&#34;{item[&#39;namespace&#39;]}-{item[&#39;name&#39;]}&#34;
                    else:
                        child_instance_name = item[&#34;namespace&#34;]
                elif item[&#34;name&#34;] is not None:
                    child_instance_name = item[&#34;name&#34;]
                else:
                    child_instance_name = &#34;&#34;

                # all job names have &#39;-&#39; instead of &#39;_&#39;
                child_instance_names.add(child_instance_name.replace(&#34;_&#34;, &#34;-&#34;))

        return_values: Set[str] = set()
        # add instane names of this sequence to all instance
        # names of its children
        if instance_names:
            for child_instance_name in child_instance_names:
                for instance_name in instance_names:
                    if child_instance_name:
                        return_values.add(f&#34;{child_instance_name}-{instance_name}&#34;)
                    else:
                        return_values.add(instance_name)
        else:
            return_values = child_instance_names

        return return_values

    @property
    def last_jobs_executed(self) -&gt; List[Job]:
        all_jobs = self.populated_jobs
        stages: Dict[str, None] = {}
        for job in all_jobs:
            # use the keys of dictionary as ordered set
            stages[job.stage] = None

        last_stage = list(stages.keys())[-1]
        last_executed_jobs: List[Job] = list()
        for job in all_jobs:
            if job._stage == last_stage:
                if job._original:
                    last_executed_jobs.append(job._original)
                else:
                    raise AttributeError(&#34;job._original is None, because the job is not a copy of another job&#34;)

        return last_executed_jobs

    @property
    def populated_jobs(self) -&gt; List[Job]:
        all_jobs: List[Job] = []
        for child in self._children:
            if isinstance(child[&#34;child&#34;], Sequence):
                for job_copy in child[&#34;child&#34;].populated_jobs:
                    job_copy._extend_namespace(child[&#34;namespace&#34;])
                    job_copy._extend_name(child[&#34;name&#34;])
                    all_jobs.append(job_copy)
            elif isinstance(child[&#34;child&#34;], Job):
                job_copy = child[&#34;child&#34;].copy()
                job_copy._extend_namespace(child[&#34;namespace&#34;])
                job_copy._extend_name(child[&#34;name&#34;])
                all_jobs.append(job_copy)

        if len(all_jobs) &gt; 0:
            first_job = all_jobs[0]
            first_job.add_needs(*self._needs)
            for job in all_jobs[1:]:
                if job._stage == first_job.stage:
                    job.add_needs(*self._needs)

        for job in all_jobs:

            if self._image_for_initialization and not job._image:
                job.set_image(self._image_for_initialization)
            if self._image_for_replacement:
                job.set_image(self._image_for_replacement)

            if self._variables_for_initialization and not job._variables:
                job._variables = copy.deepcopy(self._variables_for_initialization)
            if self._variables_for_replacement:
                job._variables = copy.deepcopy(self._variables_for_replacement)
            job.add_variables(**copy.deepcopy(self._variables))

            if self._cache_for_initialization and not job._cache:
                job._cache = copy.deepcopy(self._cache_for_initialization)
            job.set_cache(copy.deepcopy(self._cache))

            if self._tags_for_initialization and not job._tags:
                job._tags = copy.deepcopy(self._tags_for_initialization)
            if self._tags_for_replacement:
                job._tags = copy.deepcopy(self._tags_for_replacement)
            job.add_tags(*list(self._tags.keys()))

            job.add_artifacts_paths(*list(self._artifacts_paths.keys()))

            if self._rules_for_initialization and not job._rules:
                job._rules = copy.deepcopy(self._rules_for_initialization)
            if self._rules_for_replacement:
                job._rules = copy.deepcopy(self._rules_for_replacement)
            job.append_rules(*self._rules_to_append)
            job.prepend_rules(*self._rules_to_prepend)

            job.prepend_scripts(*self._scripts_to_prepend)
            job.append_scripts(*self._scripts_to_append)

        return all_jobs</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="gcip.core.sequence.ChildDict"><code class="flex name class">
<span>class <span class="ident">ChildDict</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>This data structure is supposed to store one child of a <code><a title="gcip.core.sequence.Sequence" href="#gcip.core.sequence.Sequence">Sequence</a></code> with all required information about that child.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ChildDict(TypedDict):
    &#34;&#34;&#34;This data structure is supposed to store one child of a `Sequence` with all required information about that child.&#34;&#34;&#34;

    child: Union[Job, Sequence]
    &#34;&#34;&#34;The child to store - a `gcip.core.job.Job` or `Sequence`.&#34;&#34;&#34;
    namespace: Optional[str]
    &#34;&#34;&#34;The namespace with whom the `child` was added to the `Sequence`.&#34;&#34;&#34;
    name: Optional[str]
    &#34;&#34;&#34;The name with whom the `child` was added to the `Sequence`.&#34;&#34;&#34;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.dict</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="gcip.core.sequence.ChildDict.child"><code class="name">var <span class="ident">child</span> :Â Union[<a title="gcip.core.job.Job" href="job.html#gcip.core.job.Job">Job</a>,Â <a title="gcip.core.sequence.Sequence" href="#gcip.core.sequence.Sequence">Sequence</a>]</code></dt>
<dd>
<div class="desc"><p>The child to store - a <code><a title="gcip.core.job.Job" href="job.html#gcip.core.job.Job">Job</a></code> or <code><a title="gcip.core.sequence.Sequence" href="#gcip.core.sequence.Sequence">Sequence</a></code>.</p></div>
</dd>
<dt id="gcip.core.sequence.ChildDict.name"><code class="name">var <span class="ident">name</span> :Â Optional[str]</code></dt>
<dd>
<div class="desc"><p>The name with whom the <code>child</code> was added to the <code><a title="gcip.core.sequence.Sequence" href="#gcip.core.sequence.Sequence">Sequence</a></code>.</p></div>
</dd>
<dt id="gcip.core.sequence.ChildDict.namespace"><code class="name">var <span class="ident">namespace</span> :Â Optional[str]</code></dt>
<dd>
<div class="desc"><p>The namespace with whom the <code>child</code> was added to the <code><a title="gcip.core.sequence.Sequence" href="#gcip.core.sequence.Sequence">Sequence</a></code>.</p></div>
</dd>
</dl>
</dd>
<dt id="gcip.core.sequence.Sequence"><code class="flex name class">
<span>class <span class="ident">Sequence</span></span>
</code></dt>
<dd>
<div class="desc"><p>A Sequence collects multiple <code><a title="gcip.core.job.Job" href="job.html#gcip.core.job.Job">Job</a></code>s and/or other <code><a title="gcip.core.sequence.Sequence" href="#gcip.core.sequence.Sequence">Sequence</a></code>s into a group.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Sequence:
    &#34;&#34;&#34;A Sequence collects multiple `gcip.core.job.Job`s and/or other `Sequence`s into a group.&#34;&#34;&#34;

    def __init__(self) -&gt; None:
        super().__init__()
        self._children: List[ChildDict] = list()
        self._image_for_initialization: Optional[Union[Image, str]] = None
        self._image_for_replacement: Optional[Union[Image, str]] = None
        self._variables: Dict[str, str] = {}
        self._variables_for_initialization: Dict[str, str] = {}
        self._variables_for_replacement: Dict[str, str] = {}
        self._tags: OrderedSetType = {}
        self._tags_for_initialization: OrderedSetType = {}
        self._tags_for_replacement: OrderedSetType = {}
        self._artifacts_paths: OrderedSetType = {}
        self._cache: Optional[Cache] = None
        self._cache_for_initialization: Optional[Cache] = None
        self._scripts_to_prepend: List[str] = []
        self._scripts_to_append: List[str] = []
        self._rules_to_append: List[Rule] = []
        self._rules_to_prepend: List[Rule] = []
        self._rules_for_initialization: List[Rule] = []
        self._rules_for_replacement: List[Rule] = []
        self._needs: List[Union[Job, Need]] = []
        self._parents: List[Sequence] = list()

    def _add_parent(self, parent: Sequence) -&gt; None:
        self._parents.append(parent)

    def add_children(
        self,
        *jobs_or_sequences: Union[Job, Sequence],
        namespace: Optional[str] = None,
        name: Optional[str] = None,
    ) -&gt; Sequence:
        for child in jobs_or_sequences:
            child._add_parent(self)
            self._children.append({&#34;child&#34;: child, &#34;namespace&#34;: namespace, &#34;name&#34;: name})
        return self

    def add_variables(self, **variables: str) -&gt; Sequence:
        self._variables.update(variables)
        return self

    def initialize_variables(self, **variables: str) -&gt; Sequence:
        &#34;&#34;&#34;
        Works like :meth:`initialize_tags` but for variales.

        Args:
            variables (str): A keyword argument list which key-value-pairs will be applied as variable-value-pairs
                             to all downstream :class:`Job` s without variables already set.
        &#34;&#34;&#34;
        self._variables_for_initialization.update(variables)
        return self

    def override_variables(self, **variables: str) -&gt; Sequence:
        &#34;&#34;&#34;
        Works like :meth:`override_tags` but for variables.

        Args:
            variables (str): A keyword argument list which key-value-pairs will be set as variable-value-pairs
                             to all downstream :class:`Job` s.
        &#34;&#34;&#34;
        self._variables_for_replacement.update(variables)
        return self

    def set_cache(self, cache: Cache) -&gt; Sequence:
        &#34;&#34;&#34;Sets the cache for the corresponding Sequence.
        This will override any previously set chaches on this sequence or child sequences/jobs.

        Args:
            cache (Cache): Cache to use for the Sequence and its Jobs.

        Returns:
            Sequence: Returns the modified Sequence object.
        &#34;&#34;&#34;
        self._cache = cache
        return self

    def initialize_cache(self, cache: Cache) -&gt; Sequence:
        &#34;&#34;&#34;Sets the cache of child sequences/jobs only  if not set before.

        Args:
            cache (Cache): Cache to use for the Sequence and its Jobs.

        Returns:
            Sequence: Returns the modified Sequence object.
        &#34;&#34;&#34;
        self._cache_for_initialization = cache
        return self

    def add_tags(self, *tags: str) -&gt; Sequence:
        for tag in tags:
            self._tags[tag] = None
        return self

    def initialize_tags(self, *tags: str) -&gt; Sequence:
        &#34;&#34;&#34;
        Adds tags to downstream :class:`Job` s only if they haven&#39;t tags added yet.

        :meth:`initialize_tags` would be extended by :meth:`add_tags` and overridden
        by :meth:`override_tags` if one of the other methods is called too.

        Args:
            tags (str): One or more strings that will be applied to :class:`Job` s with empty tag list.
        &#34;&#34;&#34;
        for tag in tags:
            self._tags_for_initialization[tag] = None
        return self

    def override_tags(self, *tags: str) -&gt; Sequence:
        &#34;&#34;&#34;
        Will replace all tags from downstream :class:`Job` s.

        :meth:`override_tags` will also override tags set by :meth:`initialize_tags`
        but be extended by :meth:`add_tags` when one of the other methods is called too.

        Args:
            tags (str): One or more strings that will be set as tags to all downstream :class:`Job` s.
        &#34;&#34;&#34;
        for tag in tags:
            self._tags_for_replacement[tag] = None
        return self

    def add_artifacts_paths(self, *paths: str) -&gt; Sequence:
        for path in paths:
            self._artifacts_paths[path] = None
        return self

    def append_rules(self, *rules: Rule) -&gt; Sequence:
        self._rules_to_append.extend(rules)
        return self

    def prepend_rules(self, *rules: Rule) -&gt; Sequence:
        self._rules_to_prepend = list(rules) + self._rules_to_prepend
        return self

    def initialize_rules(self, *rules: Rule) -&gt; Sequence:
        &#34;&#34;&#34;
        Works like :meth:`initialize_tags` but for rules.

        Args:
            rules (Rule): A list of :class:`Rule` s that will be applied to :class:`Job` s with empty rules list.
        &#34;&#34;&#34;
        self._rules_for_initialization.extend(rules)
        return self

    def override_rules(self, *rules: Rule) -&gt; Sequence:
        &#34;&#34;&#34;
        Works like :meth:`override_tags` but for rules.

        Args:
            rules (Rule): A list of :class:`Rule` s that will be replace all downstream :class:`Job` s rules.
        &#34;&#34;&#34;
        self._rules_for_replacement.extend(rules)
        return self

    def add_needs(self, *needs: Union[Job, Need]) -&gt; Sequence:
        &#34;&#34;&#34;
        Only the first job of the sequence get the ``need`` appended to, as well as all following jobs with
        the same stage.
        &#34;&#34;&#34;
        self._needs.extend(needs)
        return self

    def prepend_scripts(self, *scripts: str) -&gt; Sequence:
        self._scripts_to_prepend = list(scripts) + self._scripts_to_prepend
        return self

    def append_scripts(self, *scripts: str) -&gt; Sequence:
        self._scripts_to_append.extend(scripts)
        return self

    def initialize_image(self, image: Union[Image, str]) -&gt; Sequence:
        &#34;&#34;&#34;Initializes given `image` to all downstream `Job`s which do not have
        an `image` set.

        Args:
            image (Union[Image, str]): The image to set to all downstream :class:`Job`&#39;s.

        Returns:
            Sequence: Modified `sequence` object.
        &#34;&#34;&#34;
        if image:
            self._image_for_initialization = image
        return self

    def override_image(self, image: Union[Image, str]) -&gt; Sequence:
        &#34;&#34;&#34;Initializes and override&#39;s `image` to all downstream `Job`s.
        In consequence, all downstream `Job`s will be started with `image`.

        Args:
            image (str): The image to set for all downstream :class:`Job`&#39;s.

        Returns:
            Sequence: Modified `sequence` object.
        &#34;&#34;&#34;
        if image:
            self._image_for_replacement = image
        return self

    def _get_all_instance_names(self, child: Union[Job, Sequence]) -&gt; Set[str]:
        instance_names: Set[str] = set()
        for parent in self._parents:
            instance_names.update(parent._get_all_instance_names(self))

        child_instance_names: Set[str] = set()
        child_instance_name: str
        for item in self._children:
            if item[&#34;child&#34;] == child:
                if item[&#34;namespace&#34;] is not None:
                    if item[&#34;name&#34;]:
                        child_instance_name = f&#34;{item[&#39;namespace&#39;]}-{item[&#39;name&#39;]}&#34;
                    else:
                        child_instance_name = item[&#34;namespace&#34;]
                elif item[&#34;name&#34;] is not None:
                    child_instance_name = item[&#34;name&#34;]
                else:
                    child_instance_name = &#34;&#34;

                # all job names have &#39;-&#39; instead of &#39;_&#39;
                child_instance_names.add(child_instance_name.replace(&#34;_&#34;, &#34;-&#34;))

        return_values: Set[str] = set()
        # add instane names of this sequence to all instance
        # names of its children
        if instance_names:
            for child_instance_name in child_instance_names:
                for instance_name in instance_names:
                    if child_instance_name:
                        return_values.add(f&#34;{child_instance_name}-{instance_name}&#34;)
                    else:
                        return_values.add(instance_name)
        else:
            return_values = child_instance_names

        return return_values

    @property
    def last_jobs_executed(self) -&gt; List[Job]:
        all_jobs = self.populated_jobs
        stages: Dict[str, None] = {}
        for job in all_jobs:
            # use the keys of dictionary as ordered set
            stages[job.stage] = None

        last_stage = list(stages.keys())[-1]
        last_executed_jobs: List[Job] = list()
        for job in all_jobs:
            if job._stage == last_stage:
                if job._original:
                    last_executed_jobs.append(job._original)
                else:
                    raise AttributeError(&#34;job._original is None, because the job is not a copy of another job&#34;)

        return last_executed_jobs

    @property
    def populated_jobs(self) -&gt; List[Job]:
        all_jobs: List[Job] = []
        for child in self._children:
            if isinstance(child[&#34;child&#34;], Sequence):
                for job_copy in child[&#34;child&#34;].populated_jobs:
                    job_copy._extend_namespace(child[&#34;namespace&#34;])
                    job_copy._extend_name(child[&#34;name&#34;])
                    all_jobs.append(job_copy)
            elif isinstance(child[&#34;child&#34;], Job):
                job_copy = child[&#34;child&#34;].copy()
                job_copy._extend_namespace(child[&#34;namespace&#34;])
                job_copy._extend_name(child[&#34;name&#34;])
                all_jobs.append(job_copy)

        if len(all_jobs) &gt; 0:
            first_job = all_jobs[0]
            first_job.add_needs(*self._needs)
            for job in all_jobs[1:]:
                if job._stage == first_job.stage:
                    job.add_needs(*self._needs)

        for job in all_jobs:

            if self._image_for_initialization and not job._image:
                job.set_image(self._image_for_initialization)
            if self._image_for_replacement:
                job.set_image(self._image_for_replacement)

            if self._variables_for_initialization and not job._variables:
                job._variables = copy.deepcopy(self._variables_for_initialization)
            if self._variables_for_replacement:
                job._variables = copy.deepcopy(self._variables_for_replacement)
            job.add_variables(**copy.deepcopy(self._variables))

            if self._cache_for_initialization and not job._cache:
                job._cache = copy.deepcopy(self._cache_for_initialization)
            job.set_cache(copy.deepcopy(self._cache))

            if self._tags_for_initialization and not job._tags:
                job._tags = copy.deepcopy(self._tags_for_initialization)
            if self._tags_for_replacement:
                job._tags = copy.deepcopy(self._tags_for_replacement)
            job.add_tags(*list(self._tags.keys()))

            job.add_artifacts_paths(*list(self._artifacts_paths.keys()))

            if self._rules_for_initialization and not job._rules:
                job._rules = copy.deepcopy(self._rules_for_initialization)
            if self._rules_for_replacement:
                job._rules = copy.deepcopy(self._rules_for_replacement)
            job.append_rules(*self._rules_to_append)
            job.prepend_rules(*self._rules_to_prepend)

            job.prepend_scripts(*self._scripts_to_prepend)
            job.append_scripts(*self._scripts_to_append)

        return all_jobs</code></pre>
</details>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="gcip.core.pipeline.Pipeline" href="pipeline.html#gcip.core.pipeline.Pipeline">Pipeline</a></li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="gcip.core.sequence.Sequence.last_jobs_executed"><code class="name">var <span class="ident">last_jobs_executed</span> :Â List[<a title="gcip.core.job.Job" href="job.html#gcip.core.job.Job">Job</a>]</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def last_jobs_executed(self) -&gt; List[Job]:
    all_jobs = self.populated_jobs
    stages: Dict[str, None] = {}
    for job in all_jobs:
        # use the keys of dictionary as ordered set
        stages[job.stage] = None

    last_stage = list(stages.keys())[-1]
    last_executed_jobs: List[Job] = list()
    for job in all_jobs:
        if job._stage == last_stage:
            if job._original:
                last_executed_jobs.append(job._original)
            else:
                raise AttributeError(&#34;job._original is None, because the job is not a copy of another job&#34;)

    return last_executed_jobs</code></pre>
</details>
</dd>
<dt id="gcip.core.sequence.Sequence.populated_jobs"><code class="name">var <span class="ident">populated_jobs</span> :Â List[<a title="gcip.core.job.Job" href="job.html#gcip.core.job.Job">Job</a>]</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def populated_jobs(self) -&gt; List[Job]:
    all_jobs: List[Job] = []
    for child in self._children:
        if isinstance(child[&#34;child&#34;], Sequence):
            for job_copy in child[&#34;child&#34;].populated_jobs:
                job_copy._extend_namespace(child[&#34;namespace&#34;])
                job_copy._extend_name(child[&#34;name&#34;])
                all_jobs.append(job_copy)
        elif isinstance(child[&#34;child&#34;], Job):
            job_copy = child[&#34;child&#34;].copy()
            job_copy._extend_namespace(child[&#34;namespace&#34;])
            job_copy._extend_name(child[&#34;name&#34;])
            all_jobs.append(job_copy)

    if len(all_jobs) &gt; 0:
        first_job = all_jobs[0]
        first_job.add_needs(*self._needs)
        for job in all_jobs[1:]:
            if job._stage == first_job.stage:
                job.add_needs(*self._needs)

    for job in all_jobs:

        if self._image_for_initialization and not job._image:
            job.set_image(self._image_for_initialization)
        if self._image_for_replacement:
            job.set_image(self._image_for_replacement)

        if self._variables_for_initialization and not job._variables:
            job._variables = copy.deepcopy(self._variables_for_initialization)
        if self._variables_for_replacement:
            job._variables = copy.deepcopy(self._variables_for_replacement)
        job.add_variables(**copy.deepcopy(self._variables))

        if self._cache_for_initialization and not job._cache:
            job._cache = copy.deepcopy(self._cache_for_initialization)
        job.set_cache(copy.deepcopy(self._cache))

        if self._tags_for_initialization and not job._tags:
            job._tags = copy.deepcopy(self._tags_for_initialization)
        if self._tags_for_replacement:
            job._tags = copy.deepcopy(self._tags_for_replacement)
        job.add_tags(*list(self._tags.keys()))

        job.add_artifacts_paths(*list(self._artifacts_paths.keys()))

        if self._rules_for_initialization and not job._rules:
            job._rules = copy.deepcopy(self._rules_for_initialization)
        if self._rules_for_replacement:
            job._rules = copy.deepcopy(self._rules_for_replacement)
        job.append_rules(*self._rules_to_append)
        job.prepend_rules(*self._rules_to_prepend)

        job.prepend_scripts(*self._scripts_to_prepend)
        job.append_scripts(*self._scripts_to_append)

    return all_jobs</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="gcip.core.sequence.Sequence.add_artifacts_paths"><code class="name flex">
<span>def <span class="ident">add_artifacts_paths</span></span>(<span>self, *paths:Â str) â€‘>Â <a title="gcip.core.sequence.Sequence" href="#gcip.core.sequence.Sequence">Sequence</a></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_artifacts_paths(self, *paths: str) -&gt; Sequence:
    for path in paths:
        self._artifacts_paths[path] = None
    return self</code></pre>
</details>
</dd>
<dt id="gcip.core.sequence.Sequence.add_children"><code class="name flex">
<span>def <span class="ident">add_children</span></span>(<span>self, *jobs_or_sequences:Â Union[Job,Â <a title="gcip.core.sequence.Sequence" href="#gcip.core.sequence.Sequence">Sequence</a>], namespace:Â Optional[str]Â =Â None, name:Â Optional[str]Â =Â None) â€‘>Â <a title="gcip.core.sequence.Sequence" href="#gcip.core.sequence.Sequence">Sequence</a></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_children(
    self,
    *jobs_or_sequences: Union[Job, Sequence],
    namespace: Optional[str] = None,
    name: Optional[str] = None,
) -&gt; Sequence:
    for child in jobs_or_sequences:
        child._add_parent(self)
        self._children.append({&#34;child&#34;: child, &#34;namespace&#34;: namespace, &#34;name&#34;: name})
    return self</code></pre>
</details>
</dd>
<dt id="gcip.core.sequence.Sequence.add_needs"><code class="name flex">
<span>def <span class="ident">add_needs</span></span>(<span>self, *needs:Â Union[Job,Â Need]) â€‘>Â <a title="gcip.core.sequence.Sequence" href="#gcip.core.sequence.Sequence">Sequence</a></span>
</code></dt>
<dd>
<div class="desc"><p>Only the first job of the sequence get the <code>need</code> appended to, as well as all following jobs with
the same stage.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_needs(self, *needs: Union[Job, Need]) -&gt; Sequence:
    &#34;&#34;&#34;
    Only the first job of the sequence get the ``need`` appended to, as well as all following jobs with
    the same stage.
    &#34;&#34;&#34;
    self._needs.extend(needs)
    return self</code></pre>
</details>
</dd>
<dt id="gcip.core.sequence.Sequence.add_tags"><code class="name flex">
<span>def <span class="ident">add_tags</span></span>(<span>self, *tags:Â str) â€‘>Â <a title="gcip.core.sequence.Sequence" href="#gcip.core.sequence.Sequence">Sequence</a></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_tags(self, *tags: str) -&gt; Sequence:
    for tag in tags:
        self._tags[tag] = None
    return self</code></pre>
</details>
</dd>
<dt id="gcip.core.sequence.Sequence.add_variables"><code class="name flex">
<span>def <span class="ident">add_variables</span></span>(<span>self, **variables:Â str) â€‘>Â <a title="gcip.core.sequence.Sequence" href="#gcip.core.sequence.Sequence">Sequence</a></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_variables(self, **variables: str) -&gt; Sequence:
    self._variables.update(variables)
    return self</code></pre>
</details>
</dd>
<dt id="gcip.core.sequence.Sequence.append_rules"><code class="name flex">
<span>def <span class="ident">append_rules</span></span>(<span>self, *rules:Â Rule) â€‘>Â <a title="gcip.core.sequence.Sequence" href="#gcip.core.sequence.Sequence">Sequence</a></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def append_rules(self, *rules: Rule) -&gt; Sequence:
    self._rules_to_append.extend(rules)
    return self</code></pre>
</details>
</dd>
<dt id="gcip.core.sequence.Sequence.append_scripts"><code class="name flex">
<span>def <span class="ident">append_scripts</span></span>(<span>self, *scripts:Â str) â€‘>Â <a title="gcip.core.sequence.Sequence" href="#gcip.core.sequence.Sequence">Sequence</a></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def append_scripts(self, *scripts: str) -&gt; Sequence:
    self._scripts_to_append.extend(scripts)
    return self</code></pre>
</details>
</dd>
<dt id="gcip.core.sequence.Sequence.initialize_cache"><code class="name flex">
<span>def <span class="ident">initialize_cache</span></span>(<span>self, cache:Â Cache) â€‘>Â <a title="gcip.core.sequence.Sequence" href="#gcip.core.sequence.Sequence">Sequence</a></span>
</code></dt>
<dd>
<div class="desc"><p>Sets the cache of child sequences/jobs only
if not set before.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>cache</code></strong> :&ensp;<code>Cache</code></dt>
<dd>Cache to use for the Sequence and its Jobs.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="gcip.core.sequence.Sequence" href="#gcip.core.sequence.Sequence">Sequence</a></code></dt>
<dd>Returns the modified Sequence object.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def initialize_cache(self, cache: Cache) -&gt; Sequence:
    &#34;&#34;&#34;Sets the cache of child sequences/jobs only  if not set before.

    Args:
        cache (Cache): Cache to use for the Sequence and its Jobs.

    Returns:
        Sequence: Returns the modified Sequence object.
    &#34;&#34;&#34;
    self._cache_for_initialization = cache
    return self</code></pre>
</details>
</dd>
<dt id="gcip.core.sequence.Sequence.initialize_image"><code class="name flex">
<span>def <span class="ident">initialize_image</span></span>(<span>self, image:Â Union[Image,Â str]) â€‘>Â <a title="gcip.core.sequence.Sequence" href="#gcip.core.sequence.Sequence">Sequence</a></span>
</code></dt>
<dd>
<div class="desc"><p>Initializes given <code>image</code> to all downstream <code>Job</code>s which do not have
an <code>image</code> set.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>image</code></strong> :&ensp;<code>Union[Image, str]</code></dt>
<dd>The image to set to all downstream :class:<code>Job</code>'s.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="gcip.core.sequence.Sequence" href="#gcip.core.sequence.Sequence">Sequence</a></code></dt>
<dd>Modified <code>sequence</code> object.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def initialize_image(self, image: Union[Image, str]) -&gt; Sequence:
    &#34;&#34;&#34;Initializes given `image` to all downstream `Job`s which do not have
    an `image` set.

    Args:
        image (Union[Image, str]): The image to set to all downstream :class:`Job`&#39;s.

    Returns:
        Sequence: Modified `sequence` object.
    &#34;&#34;&#34;
    if image:
        self._image_for_initialization = image
    return self</code></pre>
</details>
</dd>
<dt id="gcip.core.sequence.Sequence.initialize_rules"><code class="name flex">
<span>def <span class="ident">initialize_rules</span></span>(<span>self, *rules:Â Rule) â€‘>Â <a title="gcip.core.sequence.Sequence" href="#gcip.core.sequence.Sequence">Sequence</a></span>
</code></dt>
<dd>
<div class="desc"><p>Works like :meth:<code>initialize_tags</code> but for rules.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>rules</code></strong> :&ensp;<code>Rule</code></dt>
<dd>A list of :class:<code>Rule</code> s that will be applied to :class:<code>Job</code> s with empty rules list.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def initialize_rules(self, *rules: Rule) -&gt; Sequence:
    &#34;&#34;&#34;
    Works like :meth:`initialize_tags` but for rules.

    Args:
        rules (Rule): A list of :class:`Rule` s that will be applied to :class:`Job` s with empty rules list.
    &#34;&#34;&#34;
    self._rules_for_initialization.extend(rules)
    return self</code></pre>
</details>
</dd>
<dt id="gcip.core.sequence.Sequence.initialize_tags"><code class="name flex">
<span>def <span class="ident">initialize_tags</span></span>(<span>self, *tags:Â str) â€‘>Â <a title="gcip.core.sequence.Sequence" href="#gcip.core.sequence.Sequence">Sequence</a></span>
</code></dt>
<dd>
<div class="desc"><p>Adds tags to downstream :class:<code>Job</code> s only if they haven't tags added yet.</p>
<p>:meth:<code>initialize_tags</code> would be extended by :meth:<code>add_tags</code> and overridden
by :meth:<code>override_tags</code> if one of the other methods is called too.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>tags</code></strong> :&ensp;<code>str</code></dt>
<dd>One or more strings that will be applied to :class:<code>Job</code> s with empty tag list.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def initialize_tags(self, *tags: str) -&gt; Sequence:
    &#34;&#34;&#34;
    Adds tags to downstream :class:`Job` s only if they haven&#39;t tags added yet.

    :meth:`initialize_tags` would be extended by :meth:`add_tags` and overridden
    by :meth:`override_tags` if one of the other methods is called too.

    Args:
        tags (str): One or more strings that will be applied to :class:`Job` s with empty tag list.
    &#34;&#34;&#34;
    for tag in tags:
        self._tags_for_initialization[tag] = None
    return self</code></pre>
</details>
</dd>
<dt id="gcip.core.sequence.Sequence.initialize_variables"><code class="name flex">
<span>def <span class="ident">initialize_variables</span></span>(<span>self, **variables:Â str) â€‘>Â <a title="gcip.core.sequence.Sequence" href="#gcip.core.sequence.Sequence">Sequence</a></span>
</code></dt>
<dd>
<div class="desc"><p>Works like :meth:<code>initialize_tags</code> but for variales.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>variables</code></strong> :&ensp;<code>str</code></dt>
<dd>A keyword argument list which key-value-pairs will be applied as variable-value-pairs
to all downstream :class:<code>Job</code> s without variables already set.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def initialize_variables(self, **variables: str) -&gt; Sequence:
    &#34;&#34;&#34;
    Works like :meth:`initialize_tags` but for variales.

    Args:
        variables (str): A keyword argument list which key-value-pairs will be applied as variable-value-pairs
                         to all downstream :class:`Job` s without variables already set.
    &#34;&#34;&#34;
    self._variables_for_initialization.update(variables)
    return self</code></pre>
</details>
</dd>
<dt id="gcip.core.sequence.Sequence.override_image"><code class="name flex">
<span>def <span class="ident">override_image</span></span>(<span>self, image:Â Union[Image,Â str]) â€‘>Â <a title="gcip.core.sequence.Sequence" href="#gcip.core.sequence.Sequence">Sequence</a></span>
</code></dt>
<dd>
<div class="desc"><p>Initializes and override's <code>image</code> to all downstream <code>Job</code>s.
In consequence, all downstream <code>Job</code>s will be started with <code>image</code>.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>image</code></strong> :&ensp;<code>str</code></dt>
<dd>The image to set for all downstream :class:<code>Job</code>'s.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="gcip.core.sequence.Sequence" href="#gcip.core.sequence.Sequence">Sequence</a></code></dt>
<dd>Modified <code>sequence</code> object.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def override_image(self, image: Union[Image, str]) -&gt; Sequence:
    &#34;&#34;&#34;Initializes and override&#39;s `image` to all downstream `Job`s.
    In consequence, all downstream `Job`s will be started with `image`.

    Args:
        image (str): The image to set for all downstream :class:`Job`&#39;s.

    Returns:
        Sequence: Modified `sequence` object.
    &#34;&#34;&#34;
    if image:
        self._image_for_replacement = image
    return self</code></pre>
</details>
</dd>
<dt id="gcip.core.sequence.Sequence.override_rules"><code class="name flex">
<span>def <span class="ident">override_rules</span></span>(<span>self, *rules:Â Rule) â€‘>Â <a title="gcip.core.sequence.Sequence" href="#gcip.core.sequence.Sequence">Sequence</a></span>
</code></dt>
<dd>
<div class="desc"><p>Works like :meth:<code>override_tags</code> but for rules.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>rules</code></strong> :&ensp;<code>Rule</code></dt>
<dd>A list of :class:<code>Rule</code> s that will be replace all downstream :class:<code>Job</code> s rules.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def override_rules(self, *rules: Rule) -&gt; Sequence:
    &#34;&#34;&#34;
    Works like :meth:`override_tags` but for rules.

    Args:
        rules (Rule): A list of :class:`Rule` s that will be replace all downstream :class:`Job` s rules.
    &#34;&#34;&#34;
    self._rules_for_replacement.extend(rules)
    return self</code></pre>
</details>
</dd>
<dt id="gcip.core.sequence.Sequence.override_tags"><code class="name flex">
<span>def <span class="ident">override_tags</span></span>(<span>self, *tags:Â str) â€‘>Â <a title="gcip.core.sequence.Sequence" href="#gcip.core.sequence.Sequence">Sequence</a></span>
</code></dt>
<dd>
<div class="desc"><p>Will replace all tags from downstream :class:<code>Job</code> s.</p>
<p>:meth:<code>override_tags</code> will also override tags set by :meth:<code>initialize_tags</code>
but be extended by :meth:<code>add_tags</code> when one of the other methods is called too.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>tags</code></strong> :&ensp;<code>str</code></dt>
<dd>One or more strings that will be set as tags to all downstream :class:<code>Job</code> s.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def override_tags(self, *tags: str) -&gt; Sequence:
    &#34;&#34;&#34;
    Will replace all tags from downstream :class:`Job` s.

    :meth:`override_tags` will also override tags set by :meth:`initialize_tags`
    but be extended by :meth:`add_tags` when one of the other methods is called too.

    Args:
        tags (str): One or more strings that will be set as tags to all downstream :class:`Job` s.
    &#34;&#34;&#34;
    for tag in tags:
        self._tags_for_replacement[tag] = None
    return self</code></pre>
</details>
</dd>
<dt id="gcip.core.sequence.Sequence.override_variables"><code class="name flex">
<span>def <span class="ident">override_variables</span></span>(<span>self, **variables:Â str) â€‘>Â <a title="gcip.core.sequence.Sequence" href="#gcip.core.sequence.Sequence">Sequence</a></span>
</code></dt>
<dd>
<div class="desc"><p>Works like :meth:<code>override_tags</code> but for variables.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>variables</code></strong> :&ensp;<code>str</code></dt>
<dd>A keyword argument list which key-value-pairs will be set as variable-value-pairs
to all downstream :class:<code>Job</code> s.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def override_variables(self, **variables: str) -&gt; Sequence:
    &#34;&#34;&#34;
    Works like :meth:`override_tags` but for variables.

    Args:
        variables (str): A keyword argument list which key-value-pairs will be set as variable-value-pairs
                         to all downstream :class:`Job` s.
    &#34;&#34;&#34;
    self._variables_for_replacement.update(variables)
    return self</code></pre>
</details>
</dd>
<dt id="gcip.core.sequence.Sequence.prepend_rules"><code class="name flex">
<span>def <span class="ident">prepend_rules</span></span>(<span>self, *rules:Â Rule) â€‘>Â <a title="gcip.core.sequence.Sequence" href="#gcip.core.sequence.Sequence">Sequence</a></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def prepend_rules(self, *rules: Rule) -&gt; Sequence:
    self._rules_to_prepend = list(rules) + self._rules_to_prepend
    return self</code></pre>
</details>
</dd>
<dt id="gcip.core.sequence.Sequence.prepend_scripts"><code class="name flex">
<span>def <span class="ident">prepend_scripts</span></span>(<span>self, *scripts:Â str) â€‘>Â <a title="gcip.core.sequence.Sequence" href="#gcip.core.sequence.Sequence">Sequence</a></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def prepend_scripts(self, *scripts: str) -&gt; Sequence:
    self._scripts_to_prepend = list(scripts) + self._scripts_to_prepend
    return self</code></pre>
</details>
</dd>
<dt id="gcip.core.sequence.Sequence.set_cache"><code class="name flex">
<span>def <span class="ident">set_cache</span></span>(<span>self, cache:Â Cache) â€‘>Â <a title="gcip.core.sequence.Sequence" href="#gcip.core.sequence.Sequence">Sequence</a></span>
</code></dt>
<dd>
<div class="desc"><p>Sets the cache for the corresponding Sequence.
This will override any previously set chaches on this sequence or child sequences/jobs.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>cache</code></strong> :&ensp;<code>Cache</code></dt>
<dd>Cache to use for the Sequence and its Jobs.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="gcip.core.sequence.Sequence" href="#gcip.core.sequence.Sequence">Sequence</a></code></dt>
<dd>Returns the modified Sequence object.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_cache(self, cache: Cache) -&gt; Sequence:
    &#34;&#34;&#34;Sets the cache for the corresponding Sequence.
    This will override any previously set chaches on this sequence or child sequences/jobs.

    Args:
        cache (Cache): Cache to use for the Sequence and its Jobs.

    Returns:
        Sequence: Returns the modified Sequence object.
    &#34;&#34;&#34;
    self._cache = cache
    return self</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="gcip.core" href="index.html">gcip.core</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="gcip.core.sequence.ChildDict" href="#gcip.core.sequence.ChildDict">ChildDict</a></code></h4>
<ul class="">
<li><code><a title="gcip.core.sequence.ChildDict.child" href="#gcip.core.sequence.ChildDict.child">child</a></code></li>
<li><code><a title="gcip.core.sequence.ChildDict.name" href="#gcip.core.sequence.ChildDict.name">name</a></code></li>
<li><code><a title="gcip.core.sequence.ChildDict.namespace" href="#gcip.core.sequence.ChildDict.namespace">namespace</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="gcip.core.sequence.Sequence" href="#gcip.core.sequence.Sequence">Sequence</a></code></h4>
<ul class="">
<li><code><a title="gcip.core.sequence.Sequence.add_artifacts_paths" href="#gcip.core.sequence.Sequence.add_artifacts_paths">add_artifacts_paths</a></code></li>
<li><code><a title="gcip.core.sequence.Sequence.add_children" href="#gcip.core.sequence.Sequence.add_children">add_children</a></code></li>
<li><code><a title="gcip.core.sequence.Sequence.add_needs" href="#gcip.core.sequence.Sequence.add_needs">add_needs</a></code></li>
<li><code><a title="gcip.core.sequence.Sequence.add_tags" href="#gcip.core.sequence.Sequence.add_tags">add_tags</a></code></li>
<li><code><a title="gcip.core.sequence.Sequence.add_variables" href="#gcip.core.sequence.Sequence.add_variables">add_variables</a></code></li>
<li><code><a title="gcip.core.sequence.Sequence.append_rules" href="#gcip.core.sequence.Sequence.append_rules">append_rules</a></code></li>
<li><code><a title="gcip.core.sequence.Sequence.append_scripts" href="#gcip.core.sequence.Sequence.append_scripts">append_scripts</a></code></li>
<li><code><a title="gcip.core.sequence.Sequence.initialize_cache" href="#gcip.core.sequence.Sequence.initialize_cache">initialize_cache</a></code></li>
<li><code><a title="gcip.core.sequence.Sequence.initialize_image" href="#gcip.core.sequence.Sequence.initialize_image">initialize_image</a></code></li>
<li><code><a title="gcip.core.sequence.Sequence.initialize_rules" href="#gcip.core.sequence.Sequence.initialize_rules">initialize_rules</a></code></li>
<li><code><a title="gcip.core.sequence.Sequence.initialize_tags" href="#gcip.core.sequence.Sequence.initialize_tags">initialize_tags</a></code></li>
<li><code><a title="gcip.core.sequence.Sequence.initialize_variables" href="#gcip.core.sequence.Sequence.initialize_variables">initialize_variables</a></code></li>
<li><code><a title="gcip.core.sequence.Sequence.last_jobs_executed" href="#gcip.core.sequence.Sequence.last_jobs_executed">last_jobs_executed</a></code></li>
<li><code><a title="gcip.core.sequence.Sequence.override_image" href="#gcip.core.sequence.Sequence.override_image">override_image</a></code></li>
<li><code><a title="gcip.core.sequence.Sequence.override_rules" href="#gcip.core.sequence.Sequence.override_rules">override_rules</a></code></li>
<li><code><a title="gcip.core.sequence.Sequence.override_tags" href="#gcip.core.sequence.Sequence.override_tags">override_tags</a></code></li>
<li><code><a title="gcip.core.sequence.Sequence.override_variables" href="#gcip.core.sequence.Sequence.override_variables">override_variables</a></code></li>
<li><code><a title="gcip.core.sequence.Sequence.populated_jobs" href="#gcip.core.sequence.Sequence.populated_jobs">populated_jobs</a></code></li>
<li><code><a title="gcip.core.sequence.Sequence.prepend_rules" href="#gcip.core.sequence.Sequence.prepend_rules">prepend_rules</a></code></li>
<li><code><a title="gcip.core.sequence.Sequence.prepend_scripts" href="#gcip.core.sequence.Sequence.prepend_scripts">prepend_scripts</a></code></li>
<li><code><a title="gcip.core.sequence.Sequence.set_cache" href="#gcip.core.sequence.Sequence.set_cache">set_cache</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.2</a>.</p>
</footer>
</body>
</html>