<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2" />
<title>gcip.core.job API documentation</title>
<meta name="description" content="This module represents the Gitlab CI [Job](https://docs.gitlab.com/ee/ci/yaml/README.html#job-keywords) â€¦" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>gcip.core.job</code></h1>
</header>
<section id="section-intro">
<p>This module represents the Gitlab CI <a href="https://docs.gitlab.com/ee/ci/yaml/README.html#job-keywords">Job</a></p>
<p>It contains the general <code><a title="gcip.core.job.Job" href="#gcip.core.job.Job">Job</a></code> class as well as a special <code><a title="gcip.core.job.TriggerJob" href="#gcip.core.job.TriggerJob">TriggerJob</a></code> class. The latter one is a subclass
of <code><a title="gcip.core.job.Job" href="#gcip.core.job.Job">Job</a></code> but has on the one hand reduced capabilities, on the other hand it has the additional functionality
to trigger other pipelines.</p>
<p>Here is a simple example how you define and use a <code><a title="gcip.core.job.Job" href="#gcip.core.job.Job">Job</a></code>:</p>
<pre><code class="language-python">from gcip import Pipeline, Job

pipeline = Pipeline()
job = Job(namespace=&quot;build&quot;, script=&quot;build my artefact&quot;)
pipeline.add_children(job, name=&quot;artifact&quot;)
pipeline.write_yaml()

# stages:
#   - build
# build-artifact:
#   stage: build
#   script: build my artifact
</code></pre>
<p>A <code><a title="gcip.core.job.Job" href="#gcip.core.job.Job">Job</a></code> has always a <code>script</code> and at least one of <code>namespace</code> and <code>name</code>.
The <code>namespace</code> will be used for the name of the stage of the job and the
job name itself, whereas <code>name</code> is only used for the job`s name. When adding
a job to a <code><a title="gcip.core.pipeline.Pipeline" href="pipeline.html#gcip.core.pipeline.Pipeline">Pipeline</a></code> or a <code>gcip.core.sequence.Sequence</code>
you can and should define a <code>name</code> or <code>namespace</code> too. This is how you
distinguish between two jobs of the same kind added to a pipeline:</p>
<pre><code class="language-python">def create_build_job(artifact: str) -&gt; Job:
    return Job(namespace=&quot;build&quot;, script=f&quot;build my {artifact}&quot;)

pipeline.add_children(create_build_job(&quot;foo&quot;), name=&quot;bar&quot;)
pipeline.add_children(create_build_job(&quot;john&quot;), name=&quot;deere&quot;)

# stages:
#   - build
# build-bar:
#   stage: build
#   script: build my foo
# build-deere:
#     stage: build
#     script: build my john
</code></pre>
<p>Again <code>name</code> or <code>namespace</code> decide whether to add the string to the
stage of a job or not:</p>
<pre><code class="language-python">def create_build_job(artifact: str) -&gt; Job:
    return Job(namespace=&quot;build&quot;, script=f&quot;build my {artifact}&quot;)

pipeline.add_children(create_build_job(&quot;foo&quot;), namespace=&quot;bar&quot;)
pipeline.add_children(create_build_job(&quot;john&quot;), namespace=&quot;deere&quot;)

# stages:
#   - build_bar
#   - build_deere
# build-bar:
#   stage: build_bar
#   script: build my foo
# build-deere:
#     stage: build_deere
#     script: build my john
</code></pre>
<p>This also decides whether to run the jobs in parralel or sequential. When using
<code>namespace</code> and adding the string also to the jobs stage the stages for both jobs
differ. When using <code>name</code> only the name of the jobs differ but the name of the stage
remains the same.</p>
<p>An <code><a title="gcip.core.job.Job" href="#gcip.core.job.Job">Job</a></code> object has a lot of methods for further configuration of typical Gitlab CI
[Job keywords]/<a href="https://docs.gitlab.com/ee/ci/yaml/README.html#job-keywords">https://docs.gitlab.com/ee/ci/yaml/README.html#job-keywords</a>), like
configuring tags, rules, variables and so on. Methods with names staring with..</p>
<ul>
<li><strong><code>set_*</code></strong> will initally set or overwrite any previous setting, like <code>set_image()</code></li>
<li><strong><code>add_*</code></strong> will append a value to previous ones, like <code>add_tags()</code></li>
<li><strong><code>append_*</code></strong> will do the same as <code>add_*</code>, but for values where order matters. So it
explicitly adds a value to the end of a list of previous values, like <code>append_rules()</code></li>
<li><strong><code>prepend_*</code></strong> is the counterpart to <code>append_*</code> and will add a value to the beginning
of a list of previous values, like <code>prepend_rules()</code></li>
</ul>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;This module represents the Gitlab CI [Job](https://docs.gitlab.com/ee/ci/yaml/README.html#job-keywords)

It contains the general `Job` class as well as a special `TriggerJob` class. The latter one is a subclass
of `Job` but has on the one hand reduced capabilities, on the other hand it has the additional functionality
to trigger other pipelines.

Here is a simple example how you define and use a `Job`:

```python
from gcip import Pipeline, Job

pipeline = Pipeline()
job = Job(namespace=&#34;build&#34;, script=&#34;build my artefact&#34;)
pipeline.add_children(job, name=&#34;artifact&#34;)
pipeline.write_yaml()

# stages:
#   - build
# build-artifact:
#   stage: build
#   script: build my artifact
```

A `Job` has always a `script` and at least one of `namespace` and `name`.
The `namespace` will be used for the name of the stage of the job and the
job name itself, whereas `name` is only used for the job`s name. When adding
a job to a `gcip.core.pipeline.Pipeline` or a `gcip.core.sequence.Sequence`
you can and should define a `name` or `namespace` too. This is how you
distinguish between two jobs of the same kind added to a pipeline:

```python
def create_build_job(artifact: str) -&gt; Job:
    return Job(namespace=&#34;build&#34;, script=f&#34;build my {artifact}&#34;)

pipeline.add_children(create_build_job(&#34;foo&#34;), name=&#34;bar&#34;)
pipeline.add_children(create_build_job(&#34;john&#34;), name=&#34;deere&#34;)

# stages:
#   - build
# build-bar:
#   stage: build
#   script: build my foo
# build-deere:
#     stage: build
#     script: build my john
```

Again `name` or `namespace` decide whether to add the string to the
stage of a job or not:

```python
def create_build_job(artifact: str) -&gt; Job:
    return Job(namespace=&#34;build&#34;, script=f&#34;build my {artifact}&#34;)

pipeline.add_children(create_build_job(&#34;foo&#34;), namespace=&#34;bar&#34;)
pipeline.add_children(create_build_job(&#34;john&#34;), namespace=&#34;deere&#34;)

# stages:
#   - build_bar
#   - build_deere
# build-bar:
#   stage: build_bar
#   script: build my foo
# build-deere:
#     stage: build_deere
#     script: build my john
```

This also decides whether to run the jobs in parralel or sequential. When using
`namespace` and adding the string also to the jobs stage the stages for both jobs
differ. When using `name` only the name of the jobs differ but the name of the stage
remains the same.

An `Job` object has a lot of methods for further configuration of typical Gitlab CI
[Job keywords]/https://docs.gitlab.com/ee/ci/yaml/README.html#job-keywords), like
configuring tags, rules, variables and so on. Methods with names staring with..

* **`set_*`** will initally set or overwrite any previous setting, like `set_image()`
* **`add_*`** will append a value to previous ones, like `add_tags()`
* **`append_*`** will do the same as `add_*`, but for values where order matters. So it
   explicitly adds a value to the end of a list of previous values, like `append_rules()`
* **`prepend_*`** is the counterpart to `append_*` and will add a value to the beginning
  of a list of previous values, like `prepend_rules()`
&#34;&#34;&#34;

from __future__ import annotations

import copy
from enum import Enum
from typing import (
    TYPE_CHECKING,
    Any,
    Set,
    Dict,
    List,
    Union,
    AnyStr,
    Mapping,
    Optional,
)
from operator import itemgetter

from . import OrderedSetType
from .need import Need
from .rule import Rule
from .cache import Cache
from .image import Image
from .include import Include

if TYPE_CHECKING:
    from .job_sequence import JobSequence

__author__ = &#34;Thomas Steinbach&#34;
__copyright__ = &#34;Copyright 2020 DB Systel GmbH&#34;
__credits__ = [&#34;Thomas Steinbach&#34;, &#34;Daniel von EÃŸen&#34;]
# SPDX-License-Identifier: Apache-2.0
__license__ = &#39;Apache-2.0&#39;
__maintainer__ = &#39;Thomas Steinbach&#39;
__email__ = &#39;thomas.t.steinbach@deutschebahn.com&#39;


class Job():
    &#34;&#34;&#34;This class represents the Gitlab CI [Job](https://docs.gitlab.com/ee/ci/yaml/README.html#job-keywords)

    Attributes:
        script (Union[AnyStr, List[str]]): The [script(s)](https://docs.gitlab.com/ee/ci/yaml/README.html#script) to be executed.
        name (Optional[str]): The name of the job. In opposite to `namespace` only the name is set and not the stage of the job.
            If `name` is set, than the jobs stage has no value, which defaults to the &#39;test&#39; stage.
            Either `name` or `namespace` must be set. Defaults to `None`.
        namespace (Optional[str]): The name and stage of the job. In opposite to `name` also the jobs stage will be setup with this value.
            Either `name` or `namespace` must be set. Defaults to `None`.
    &#34;&#34;&#34;
    def __init__(
        self,
        *,
        script: Union[AnyStr, List[str]],
        name: Optional[str] = None,
        namespace: Optional[str] = None,
    ):
        self._stage = &#34;&#34;
        self._name = &#34;&#34;
        self._image: Optional[Image] = None
        self._variables: Dict[str, str] = {}
        self._tags: OrderedSetType = {}
        self._rules: List[Rule] = []
        self._needs: List[Union[Need, Job, JobSequence]] = []
        self._scripts: List[str]
        self._artifacts_paths: OrderedSetType = {}
        self._cache: Optional[Cache] = None
        self._parents: List[JobSequence] = list()
        self._original: Optional[Job]
        &#34;&#34;&#34;Only set if you get a :meth:`copy()` of this job&#34;&#34;&#34;

        if namespace and name:
            self._name = f&#34;{namespace}-{name}&#34;
            self._stage = namespace
        elif namespace:
            self._name = namespace
            self._stage = namespace
        elif name:
            self._name = name
            # default for unset stages is &#39;test&#39; -&gt; https://docs.gitlab.com/ee/ci/yaml/#stages
            self._stage = &#34;test&#34;
        else:
            raise ValueError(&#34;At least one of the parameters `name` or `namespace` have to be set.&#34;)

        self._name = self._name.replace(&#34;_&#34;, &#34;-&#34;)
        self._stage = self._stage.replace(&#34;-&#34;, &#34;_&#34;)

        if isinstance(script, str):
            self._scripts = [script]
        elif isinstance(script, list):
            self._scripts = script
        else:
            raise AttributeError(&#34;script parameter must be of type string or list of strings&#34;)

    @property
    def name(self) -&gt; str:
        &#34;&#34;&#34;The name of the Job

        This property is affected by the rendering process, where `gcip.core.job.Sequence`s will
        populate the job name depending on their names. That means you can be sure to get the jobs
        final name when rendered.
        &#34;&#34;&#34;
        return self._name

    @property
    def stage(self) -&gt; str:
        &#34;&#34;&#34;The [stage](https://docs.gitlab.com/ee/ci/yaml/README.html#stage) of the Job

        This property is affected by the rendering process, where `gcip.core.job.Sequence`s will
        populate the job stage depending on their namespaces. That means you can be sure to get the jobs
        final stage when rendered.
        &#34;&#34;&#34;
        return self._stage

    def _extend_name(self, name: Optional[str]) -&gt; None:
        &#34;&#34;&#34;This method is used by `gcip.core.job.Sequence`s to populate the jobs name.&#34;&#34;&#34;
        if name:
            self._name += &#34;-&#34; + name.replace(&#34;_&#34;, &#34;-&#34;)

    def _extend_stage(self, stage: Optional[str]) -&gt; None:
        &#34;&#34;&#34;This method is used by `gcip.core.job.Sequence`s to populate the jobs stage.&#34;&#34;&#34;
        if stage:
            self._stage += &#34;_&#34; + stage.replace(&#34;-&#34;, &#34;_&#34;)

    def _extend_namespace(self, namespace: Optional[str]) -&gt; None:
        &#34;&#34;&#34;This method is used by `gcip.core.job.Sequence`s to populate the jobs name and stage.&#34;&#34;&#34;
        if namespace:
            self._extend_name(namespace)
            self._extend_stage(namespace)

    def _add_parent(self, parent: JobSequence) -&gt; None:
        &#34;&#34;&#34;This method is called by `gcip.core.job.Sequence`s when the job is added to that sequence.

        The job needs to know its parents when `_get_all_instance_names()` is called.
        &#34;&#34;&#34;
        self._parents.append(parent)

    def prepend_scripts(self, *scripts: str) -&gt; Job:
        &#34;&#34;&#34;Inserts one or more [script](https://docs.gitlab.com/ee/ci/yaml/README.html#script)s before the current scripts.

        Returns:
            `Job`: The modified `Job` object.
        &#34;&#34;&#34;
        self._scripts = list(scripts) + self._scripts
        return self

    def append_scripts(self, *scripts: str) -&gt; Job:
        &#34;&#34;&#34;Adds one or more [script](https://docs.gitlab.com/ee/ci/yaml/README.html#script)s after the current scripts.

        Returns:
            `Job`: The modified `Job` object.
        &#34;&#34;&#34;
        self._scripts.extend(scripts)
        return self

    def add_variables(self, **variables: str) -&gt; Job:
        &#34;&#34;&#34;Adds one or more [variables](https://docs.gitlab.com/ee/ci/yaml/README.html#variables), each as keyword argument,
        to the job.

        Args:
            **variables (str): Each variable would be provided as keyword argument:
        ```
        job.add_variables(GREETING=&#34;hello&#34;, LANGUAGE=&#34;python&#34;)
        ```

        Returns:
            `Job`: The modified `Job` object.
        &#34;&#34;&#34;
        self._variables.update(variables)
        return self

    def add_tags(self, *tags: str) -&gt; Job:
        &#34;&#34;&#34;Adds one or more [tags](https://docs.gitlab.com/ee/ci/yaml/README.html#tags) to the job.

        Returns:
            `Job`: The modified `Job` object.
        &#34;&#34;&#34;
        for tag in tags:
            self._tags[tag] = None
        return self

    def add_artifacts_paths(self, *paths: str) -&gt; Job:
        &#34;&#34;&#34;Adds one or more [artifact:paths](https://docs.gitlab.com/ee/ci/yaml/README.html#artifactspaths) to the job.

        Returns:
            `Job`: The modified `Job` object.
        &#34;&#34;&#34;
        for path in paths:
            self._artifacts_paths[path] = None
        return self

    def set_cache(self, cache: Optional[Cache]) -&gt; Job:
        &#34;&#34;&#34;Sets the [cache](https://docs.gitlab.com/ee/ci/yaml/README.html#cache) of the Job.

        Any previous values will be overwritten.

        Args:
            cache (Optional[Cache]): See `gcip.core.cache.Cache` class.

        Returns:
            JobSequence: Returns the modified `Job` object.
        &#34;&#34;&#34;
        if cache:
            self._cache = cache
        return self

    def append_rules(self, *rules: Rule) -&gt; Job:
        &#34;&#34;&#34;Adds one or more  [rule](https://docs.gitlab.com/ee/ci/yaml/README.html#rules)s behind the current rules of the job.

        Args:
            *rules (Rule): See `gcip.core.rule.Rule` class.

        Returns:
            JobSequence: Returns the modified `Job` object.
        &#34;&#34;&#34;
        self._rules.extend(rules)
        return self

    def prepend_rules(self, *rules: Rule) -&gt; Job:
        &#34;&#34;&#34;Inserts one or more  [rule](https://docs.gitlab.com/ee/ci/yaml/README.html#rules)s before the current rules of the job.

        Args:
            *rules (Rule): See `gcip.core.rule.Rule` class.

        Returns:
            JobSequence: Returns the modified `Job` object.
        &#34;&#34;&#34;
        self._rules = list(rules) + self._rules
        return self

    def add_needs(self, *needs: Union[Need, Job, JobSequence]) -&gt; Job:
        &#34;&#34;&#34;Add one or more [needs](https://docs.gitlab.com/ee/ci/yaml/README.html#needs) to the job.

        Args:
            *needs (Union[Need, Job, JobSequence]):

        Returns:
            JobSequence: Returns the modified `Job` object.
        &#34;&#34;&#34;
        self._needs.extend(needs)
        return self

    def set_image(self, image: Optional[Union[Image, str]]) -&gt; Job:
        &#34;&#34;&#34;Sets the image of this job.

        For a simple container image you can provide the origin of the image.
        If you want to set the entrypoint, you have to provide an Image object instead.

        Args:
            image (Optional[Union[Image, str]]): Can be either `string` or `Image`.

        Returns:
            Job: Returns the modified :class:`Job` object.
        &#34;&#34;&#34;
        if image:
            if isinstance(image, str):
                image = Image(image)
            self._image = image
        return self

    def _get_all_instance_names(self) -&gt; Set[str]:
        &#34;&#34;&#34;Query all the possible names this job can have by residing within parent `gcip.core.sequence.Sequence`s.

        The possible image names are built by the `name` of this job plus all the possible prefix values from
        parent parent `gcip.core.sequence.Sequence`s. The prefix values from parent sequences are their names
        prefixed with the names of the parent parent sequences and so on.

        Imagine Job `A` resides within following sequenes:

        ```
        B:
          A
        C:
          D:
            A
        ```

        Then the instance names of `A` would be `A-B` and `A-D-C`.
        &#34;&#34;&#34;
        instance_names: Set[str] = set()
        for parent in self._parents:
            for postfix in parent._get_all_instance_names(self):
                if postfix:
                    instance_names.add(f&#34;{self._name}-{postfix}&#34;)
                else:
                    instance_names.add(self._name)
        return instance_names

    def copy(self) -&gt; Job:
        &#34;&#34;&#34;Returns a independent, deep copy object of this job.&#34;&#34;&#34;
        return self._copy_into(Job(name=&#34;&lt;set in _copy_into()&#34;, script=copy.deepcopy(self._scripts)))

    def _copy_into(self, job: Job) -&gt; Job:
        job._original = self
        job._name = self._name
        job._stage = self._stage

        job.set_image(self._image)
        job.add_variables(**copy.deepcopy(self._variables))
        job.add_tags(*list(self._tags.keys()))
        job.add_artifacts_paths(*list(self._artifacts_paths.keys()))
        job.set_cache(self._cache)
        job.append_rules(*self._rules)
        job.add_needs(*self._needs)
        job._parents = self._parents.copy()

        return job

    def render(self) -&gt; Dict[str, Any]:
        from .job_sequence import \
            JobSequence  # late import to avoid circular dependencies

        rendered_job: Dict[str, Any] = {}

        if self._image:
            rendered_job.update({&#34;image&#34;: self._image.render()})

        if self._needs:
            need_jobs: List[Job] = list()
            rendered_needs: List[Dict[str, Union[str, bool]]] = list()
            for need in self._needs:
                if isinstance(need, Job):
                    need_jobs.append(need)
                elif isinstance(need, JobSequence):
                    for job in need.last_jobs_executed:
                        need_jobs.append(job)
                elif isinstance(need, Need):
                    rendered_needs.append(need.render())
                else:
                    raise TypeError(f&#34;Need &#39;{need}&#39; is of type {type(need)}.&#34;)

            job_names: Set[str] = set()
            for job in need_jobs:
                job_names.update(job._get_all_instance_names())

            for name in job_names:
                rendered_needs.append(Need(name).render())

            # sort needs by the name of the referenced job
            rendered_needs = sorted(rendered_needs, key=itemgetter(&#34;job&#34;))

            rendered_job.update({&#34;needs&#34;: rendered_needs})

        rendered_job.update({
            &#34;stage&#34;: self._stage,
            &#34;script&#34;: self._scripts,
        })

        if self._variables:
            rendered_job[&#34;variables&#34;] = self._variables

        if self._rules:
            rendered_rules = []
            for rule in self._rules:
                rendered_rules.append(rule.render())
            rendered_job.update({&#34;rules&#34;: rendered_rules})

        if self._artifacts_paths.keys():
            rendered_job.update({&#34;artifacts&#34;: {
                &#34;paths&#34;: list(self._artifacts_paths.keys()),
            }})

        if self._cache:
            rendered_job.update({&#34;cache&#34;: self._cache.render()})

        if self._tags.keys():
            rendered_job[&#34;tags&#34;] = list(self._tags.keys())

        return rendered_job


class TriggerStrategy(Enum):
    &#34;&#34;&#34;Class with static values for ``TriggerStrategy`` used together with :class:`gcip.core.job.TriggerJob`. To construct an object.&#34;&#34;&#34;
    DEPEND = &#34;depend&#34;


class TriggerJob(Job):
    def __init__(
        self,
        *args: Any,
        name: Optional[str] = None,
        namespace: Optional[str] = None,
        project: Optional[str] = None,
        branch: Optional[str] = None,
        includes: Union[Include, List[Include], None] = None,
        strategy: Optional[TriggerStrategy] = None,
        **kwargs: Mapping[Any, Any],
    ) -&gt; None:
        &#34;&#34;&#34;
        Class to create a Gitlab CI Trigger.

        You can create either a &#34;Parent-child&#34; or a &#34;Multi-project&#34; pipeline trigger.


        Args:
            project (Optional[str]): Used to create Multi-project pipeline trigger, exclusive to ``includes`` given Gitlab project name.
                e.g &#39;team1/project1&#39;. Defaults to None.
            branch (Optional[str]): If ``project`` is given, you can specify which branch of ``project`` to trigger. Defaults to None.
            includes (Optional[List[Include]]): Used to create Parent-child pipeline trigger, exclusiv to ``project``. Defaults to None.
            strategy (Optional[TriggerStrategy]): Strategy of how the job behaves from the upstream pipeline.
                If :class:`TriggerStrategy.DEPEND`, any triggered job failed this job failed as well. Defaults to None.

        Raises:
            ValueError: If ``project`` and ``includes`` is given at the same time.
            ValueError: There is a Gitlab CI limitation, in &#34;Parent-child&#34; pipelines it is only allowed to add max. three includes.
        &#34;&#34;&#34;

        if includes and project:
            raise ValueError((&#34;You cannot specify &#39;include&#39; and &#39;project&#39; together. Either &#39;include&#39; or &#39;project&#39; is possible.&#34;))
        if not includes and not project:
            raise ValueError(&#34;Neither &#39;includes&#39; nor &#39;project&#39; is given.&#34;)

        super().__init__(name=name, namespace=namespace, script=&#34;none&#34;)

        self._project = project
        self._branch = branch
        self._strategy = strategy

        if not includes:
            self._includes = None
        elif isinstance(includes, Include):
            self._includes = [includes]
        elif isinstance(includes, list):
            if len(includes) &gt; 3:
                raise ValueError(
                    (
                        &#34;The length of &#39;includes&#39; is limited to three.&#34;
                        &#34;See https://docs.gitlab.com/ee/ci/parent_child_pipelines.html for more information.&#34;
                    )
                )
            self._includes = includes
        else:
            raise AttributeError(&#34;script parameter must be of type string or list of strings&#34;)

    def copy(self) -&gt; TriggerJob:
        job_copy = TriggerJob(name=&#34;.&#34;, project=&#34;.&#34;)
        super()._copy_into(job_copy)

        job_copy._project = self._project
        job_copy._branch = self._branch
        job_copy._includes = self._includes
        job_copy._strategy = self._strategy
        return job_copy

    def render(self) -&gt; Dict[Any, Any]:
        rendered_job = super().render()

        # remove unsupported keywords from TriggerJob
        rendered_job.pop(&#34;script&#34;)

        if &#34;image&#34; in rendered_job:
            rendered_job.pop(&#34;image&#34;)

        if &#34;tags&#34; in rendered_job:
            rendered_job.pop(&#34;tags&#34;)

        if &#34;artifacts&#34; in rendered_job:
            rendered_job.pop(&#34;artifacts&#34;)

        if &#34;cache&#34; in rendered_job:
            rendered_job.pop(&#34;cache&#34;)

        trigger: Dict[str, Union[str, List[Dict[str, str]]]] = {}

        # Child pipelines
        if self._includes:
            trigger.update({
                &#34;include&#34;: [include.render() for include in self._includes],
            })

        # Multiproject pipelines
        if self._project:
            trigger.update({
                &#34;project&#34;: self._project,
            })
            if self._branch:
                trigger.update({&#34;branch&#34;: self._branch})

        if self._strategy:
            trigger.update({&#34;strategy&#34;: self._strategy.value})

        rendered_job = {
            &#34;trigger&#34;: trigger,
            **rendered_job
        }

        return rendered_job</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="gcip.core.job.Job"><code class="flex name class">
<span>class <span class="ident">Job</span></span>
<span>(</span><span>*, script:Â Union[AnyStr,Â List[str]], name:Â Optional[str]Â =Â None, namespace:Â Optional[str]Â =Â None)</span>
</code></dt>
<dd>
<div class="desc"><p>This class represents the Gitlab CI <a href="https://docs.gitlab.com/ee/ci/yaml/README.html#job-keywords">Job</a></p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>script</code></strong> :&ensp;<code>Union[AnyStr, List[str]]</code></dt>
<dd>The <a href="https://docs.gitlab.com/ee/ci/yaml/README.html#script">script(s)</a> to be executed.</dd>
<dt><strong><code>name</code></strong> :&ensp;<code>Optional[str]</code></dt>
<dd>The name of the job. In opposite to <code>namespace</code> only the name is set and not the stage of the job.
If <code>name</code> is set, than the jobs stage has no value, which defaults to the 'test' stage.
Either <code>name</code> or <code>namespace</code> must be set. Defaults to <code>None</code>.</dd>
<dt><strong><code>namespace</code></strong> :&ensp;<code>Optional[str]</code></dt>
<dd>The name and stage of the job. In opposite to <code>name</code> also the jobs stage will be setup with this value.
Either <code>name</code> or <code>namespace</code> must be set. Defaults to <code>None</code>.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Job():
    &#34;&#34;&#34;This class represents the Gitlab CI [Job](https://docs.gitlab.com/ee/ci/yaml/README.html#job-keywords)

    Attributes:
        script (Union[AnyStr, List[str]]): The [script(s)](https://docs.gitlab.com/ee/ci/yaml/README.html#script) to be executed.
        name (Optional[str]): The name of the job. In opposite to `namespace` only the name is set and not the stage of the job.
            If `name` is set, than the jobs stage has no value, which defaults to the &#39;test&#39; stage.
            Either `name` or `namespace` must be set. Defaults to `None`.
        namespace (Optional[str]): The name and stage of the job. In opposite to `name` also the jobs stage will be setup with this value.
            Either `name` or `namespace` must be set. Defaults to `None`.
    &#34;&#34;&#34;
    def __init__(
        self,
        *,
        script: Union[AnyStr, List[str]],
        name: Optional[str] = None,
        namespace: Optional[str] = None,
    ):
        self._stage = &#34;&#34;
        self._name = &#34;&#34;
        self._image: Optional[Image] = None
        self._variables: Dict[str, str] = {}
        self._tags: OrderedSetType = {}
        self._rules: List[Rule] = []
        self._needs: List[Union[Need, Job, JobSequence]] = []
        self._scripts: List[str]
        self._artifacts_paths: OrderedSetType = {}
        self._cache: Optional[Cache] = None
        self._parents: List[JobSequence] = list()
        self._original: Optional[Job]
        &#34;&#34;&#34;Only set if you get a :meth:`copy()` of this job&#34;&#34;&#34;

        if namespace and name:
            self._name = f&#34;{namespace}-{name}&#34;
            self._stage = namespace
        elif namespace:
            self._name = namespace
            self._stage = namespace
        elif name:
            self._name = name
            # default for unset stages is &#39;test&#39; -&gt; https://docs.gitlab.com/ee/ci/yaml/#stages
            self._stage = &#34;test&#34;
        else:
            raise ValueError(&#34;At least one of the parameters `name` or `namespace` have to be set.&#34;)

        self._name = self._name.replace(&#34;_&#34;, &#34;-&#34;)
        self._stage = self._stage.replace(&#34;-&#34;, &#34;_&#34;)

        if isinstance(script, str):
            self._scripts = [script]
        elif isinstance(script, list):
            self._scripts = script
        else:
            raise AttributeError(&#34;script parameter must be of type string or list of strings&#34;)

    @property
    def name(self) -&gt; str:
        &#34;&#34;&#34;The name of the Job

        This property is affected by the rendering process, where `gcip.core.job.Sequence`s will
        populate the job name depending on their names. That means you can be sure to get the jobs
        final name when rendered.
        &#34;&#34;&#34;
        return self._name

    @property
    def stage(self) -&gt; str:
        &#34;&#34;&#34;The [stage](https://docs.gitlab.com/ee/ci/yaml/README.html#stage) of the Job

        This property is affected by the rendering process, where `gcip.core.job.Sequence`s will
        populate the job stage depending on their namespaces. That means you can be sure to get the jobs
        final stage when rendered.
        &#34;&#34;&#34;
        return self._stage

    def _extend_name(self, name: Optional[str]) -&gt; None:
        &#34;&#34;&#34;This method is used by `gcip.core.job.Sequence`s to populate the jobs name.&#34;&#34;&#34;
        if name:
            self._name += &#34;-&#34; + name.replace(&#34;_&#34;, &#34;-&#34;)

    def _extend_stage(self, stage: Optional[str]) -&gt; None:
        &#34;&#34;&#34;This method is used by `gcip.core.job.Sequence`s to populate the jobs stage.&#34;&#34;&#34;
        if stage:
            self._stage += &#34;_&#34; + stage.replace(&#34;-&#34;, &#34;_&#34;)

    def _extend_namespace(self, namespace: Optional[str]) -&gt; None:
        &#34;&#34;&#34;This method is used by `gcip.core.job.Sequence`s to populate the jobs name and stage.&#34;&#34;&#34;
        if namespace:
            self._extend_name(namespace)
            self._extend_stage(namespace)

    def _add_parent(self, parent: JobSequence) -&gt; None:
        &#34;&#34;&#34;This method is called by `gcip.core.job.Sequence`s when the job is added to that sequence.

        The job needs to know its parents when `_get_all_instance_names()` is called.
        &#34;&#34;&#34;
        self._parents.append(parent)

    def prepend_scripts(self, *scripts: str) -&gt; Job:
        &#34;&#34;&#34;Inserts one or more [script](https://docs.gitlab.com/ee/ci/yaml/README.html#script)s before the current scripts.

        Returns:
            `Job`: The modified `Job` object.
        &#34;&#34;&#34;
        self._scripts = list(scripts) + self._scripts
        return self

    def append_scripts(self, *scripts: str) -&gt; Job:
        &#34;&#34;&#34;Adds one or more [script](https://docs.gitlab.com/ee/ci/yaml/README.html#script)s after the current scripts.

        Returns:
            `Job`: The modified `Job` object.
        &#34;&#34;&#34;
        self._scripts.extend(scripts)
        return self

    def add_variables(self, **variables: str) -&gt; Job:
        &#34;&#34;&#34;Adds one or more [variables](https://docs.gitlab.com/ee/ci/yaml/README.html#variables), each as keyword argument,
        to the job.

        Args:
            **variables (str): Each variable would be provided as keyword argument:
        ```
        job.add_variables(GREETING=&#34;hello&#34;, LANGUAGE=&#34;python&#34;)
        ```

        Returns:
            `Job`: The modified `Job` object.
        &#34;&#34;&#34;
        self._variables.update(variables)
        return self

    def add_tags(self, *tags: str) -&gt; Job:
        &#34;&#34;&#34;Adds one or more [tags](https://docs.gitlab.com/ee/ci/yaml/README.html#tags) to the job.

        Returns:
            `Job`: The modified `Job` object.
        &#34;&#34;&#34;
        for tag in tags:
            self._tags[tag] = None
        return self

    def add_artifacts_paths(self, *paths: str) -&gt; Job:
        &#34;&#34;&#34;Adds one or more [artifact:paths](https://docs.gitlab.com/ee/ci/yaml/README.html#artifactspaths) to the job.

        Returns:
            `Job`: The modified `Job` object.
        &#34;&#34;&#34;
        for path in paths:
            self._artifacts_paths[path] = None
        return self

    def set_cache(self, cache: Optional[Cache]) -&gt; Job:
        &#34;&#34;&#34;Sets the [cache](https://docs.gitlab.com/ee/ci/yaml/README.html#cache) of the Job.

        Any previous values will be overwritten.

        Args:
            cache (Optional[Cache]): See `gcip.core.cache.Cache` class.

        Returns:
            JobSequence: Returns the modified `Job` object.
        &#34;&#34;&#34;
        if cache:
            self._cache = cache
        return self

    def append_rules(self, *rules: Rule) -&gt; Job:
        &#34;&#34;&#34;Adds one or more  [rule](https://docs.gitlab.com/ee/ci/yaml/README.html#rules)s behind the current rules of the job.

        Args:
            *rules (Rule): See `gcip.core.rule.Rule` class.

        Returns:
            JobSequence: Returns the modified `Job` object.
        &#34;&#34;&#34;
        self._rules.extend(rules)
        return self

    def prepend_rules(self, *rules: Rule) -&gt; Job:
        &#34;&#34;&#34;Inserts one or more  [rule](https://docs.gitlab.com/ee/ci/yaml/README.html#rules)s before the current rules of the job.

        Args:
            *rules (Rule): See `gcip.core.rule.Rule` class.

        Returns:
            JobSequence: Returns the modified `Job` object.
        &#34;&#34;&#34;
        self._rules = list(rules) + self._rules
        return self

    def add_needs(self, *needs: Union[Need, Job, JobSequence]) -&gt; Job:
        &#34;&#34;&#34;Add one or more [needs](https://docs.gitlab.com/ee/ci/yaml/README.html#needs) to the job.

        Args:
            *needs (Union[Need, Job, JobSequence]):

        Returns:
            JobSequence: Returns the modified `Job` object.
        &#34;&#34;&#34;
        self._needs.extend(needs)
        return self

    def set_image(self, image: Optional[Union[Image, str]]) -&gt; Job:
        &#34;&#34;&#34;Sets the image of this job.

        For a simple container image you can provide the origin of the image.
        If you want to set the entrypoint, you have to provide an Image object instead.

        Args:
            image (Optional[Union[Image, str]]): Can be either `string` or `Image`.

        Returns:
            Job: Returns the modified :class:`Job` object.
        &#34;&#34;&#34;
        if image:
            if isinstance(image, str):
                image = Image(image)
            self._image = image
        return self

    def _get_all_instance_names(self) -&gt; Set[str]:
        &#34;&#34;&#34;Query all the possible names this job can have by residing within parent `gcip.core.sequence.Sequence`s.

        The possible image names are built by the `name` of this job plus all the possible prefix values from
        parent parent `gcip.core.sequence.Sequence`s. The prefix values from parent sequences are their names
        prefixed with the names of the parent parent sequences and so on.

        Imagine Job `A` resides within following sequenes:

        ```
        B:
          A
        C:
          D:
            A
        ```

        Then the instance names of `A` would be `A-B` and `A-D-C`.
        &#34;&#34;&#34;
        instance_names: Set[str] = set()
        for parent in self._parents:
            for postfix in parent._get_all_instance_names(self):
                if postfix:
                    instance_names.add(f&#34;{self._name}-{postfix}&#34;)
                else:
                    instance_names.add(self._name)
        return instance_names

    def copy(self) -&gt; Job:
        &#34;&#34;&#34;Returns a independent, deep copy object of this job.&#34;&#34;&#34;
        return self._copy_into(Job(name=&#34;&lt;set in _copy_into()&#34;, script=copy.deepcopy(self._scripts)))

    def _copy_into(self, job: Job) -&gt; Job:
        job._original = self
        job._name = self._name
        job._stage = self._stage

        job.set_image(self._image)
        job.add_variables(**copy.deepcopy(self._variables))
        job.add_tags(*list(self._tags.keys()))
        job.add_artifacts_paths(*list(self._artifacts_paths.keys()))
        job.set_cache(self._cache)
        job.append_rules(*self._rules)
        job.add_needs(*self._needs)
        job._parents = self._parents.copy()

        return job

    def render(self) -&gt; Dict[str, Any]:
        from .job_sequence import \
            JobSequence  # late import to avoid circular dependencies

        rendered_job: Dict[str, Any] = {}

        if self._image:
            rendered_job.update({&#34;image&#34;: self._image.render()})

        if self._needs:
            need_jobs: List[Job] = list()
            rendered_needs: List[Dict[str, Union[str, bool]]] = list()
            for need in self._needs:
                if isinstance(need, Job):
                    need_jobs.append(need)
                elif isinstance(need, JobSequence):
                    for job in need.last_jobs_executed:
                        need_jobs.append(job)
                elif isinstance(need, Need):
                    rendered_needs.append(need.render())
                else:
                    raise TypeError(f&#34;Need &#39;{need}&#39; is of type {type(need)}.&#34;)

            job_names: Set[str] = set()
            for job in need_jobs:
                job_names.update(job._get_all_instance_names())

            for name in job_names:
                rendered_needs.append(Need(name).render())

            # sort needs by the name of the referenced job
            rendered_needs = sorted(rendered_needs, key=itemgetter(&#34;job&#34;))

            rendered_job.update({&#34;needs&#34;: rendered_needs})

        rendered_job.update({
            &#34;stage&#34;: self._stage,
            &#34;script&#34;: self._scripts,
        })

        if self._variables:
            rendered_job[&#34;variables&#34;] = self._variables

        if self._rules:
            rendered_rules = []
            for rule in self._rules:
                rendered_rules.append(rule.render())
            rendered_job.update({&#34;rules&#34;: rendered_rules})

        if self._artifacts_paths.keys():
            rendered_job.update({&#34;artifacts&#34;: {
                &#34;paths&#34;: list(self._artifacts_paths.keys()),
            }})

        if self._cache:
            rendered_job.update({&#34;cache&#34;: self._cache.render()})

        if self._tags.keys():
            rendered_job[&#34;tags&#34;] = list(self._tags.keys())

        return rendered_job</code></pre>
</details>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="gcip.core.job.TriggerJob" href="#gcip.core.job.TriggerJob">TriggerJob</a></li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="gcip.core.job.Job.name"><code class="name">var <span class="ident">name</span> :Â str</code></dt>
<dd>
<div class="desc"><p>The name of the Job</p>
<p>This property is affected by the rendering process, where <code>gcip.core.job.Sequence</code>s will
populate the job name depending on their names. That means you can be sure to get the jobs
final name when rendered.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def name(self) -&gt; str:
    &#34;&#34;&#34;The name of the Job

    This property is affected by the rendering process, where `gcip.core.job.Sequence`s will
    populate the job name depending on their names. That means you can be sure to get the jobs
    final name when rendered.
    &#34;&#34;&#34;
    return self._name</code></pre>
</details>
</dd>
<dt id="gcip.core.job.Job.stage"><code class="name">var <span class="ident">stage</span> :Â str</code></dt>
<dd>
<div class="desc"><p>The <a href="https://docs.gitlab.com/ee/ci/yaml/README.html#stage">stage</a> of the Job</p>
<p>This property is affected by the rendering process, where <code>gcip.core.job.Sequence</code>s will
populate the job stage depending on their namespaces. That means you can be sure to get the jobs
final stage when rendered.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def stage(self) -&gt; str:
    &#34;&#34;&#34;The [stage](https://docs.gitlab.com/ee/ci/yaml/README.html#stage) of the Job

    This property is affected by the rendering process, where `gcip.core.job.Sequence`s will
    populate the job stage depending on their namespaces. That means you can be sure to get the jobs
    final stage when rendered.
    &#34;&#34;&#34;
    return self._stage</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="gcip.core.job.Job.add_artifacts_paths"><code class="name flex">
<span>def <span class="ident">add_artifacts_paths</span></span>(<span>self, *paths:Â str) â€‘>Â <a title="gcip.core.job.Job" href="#gcip.core.job.Job">Job</a></span>
</code></dt>
<dd>
<div class="desc"><p>Adds one or more <a href="https://docs.gitlab.com/ee/ci/yaml/README.html#artifactspaths">artifact:paths</a> to the job.</p>
<h2 id="returns">Returns</h2>
<p><code><a title="gcip.core.job.Job" href="#gcip.core.job.Job">Job</a></code>: The modified <code><a title="gcip.core.job.Job" href="#gcip.core.job.Job">Job</a></code> object.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_artifacts_paths(self, *paths: str) -&gt; Job:
    &#34;&#34;&#34;Adds one or more [artifact:paths](https://docs.gitlab.com/ee/ci/yaml/README.html#artifactspaths) to the job.

    Returns:
        `Job`: The modified `Job` object.
    &#34;&#34;&#34;
    for path in paths:
        self._artifacts_paths[path] = None
    return self</code></pre>
</details>
</dd>
<dt id="gcip.core.job.Job.add_needs"><code class="name flex">
<span>def <span class="ident">add_needs</span></span>(<span>self, *needs:Â Union[Need,Â <a title="gcip.core.job.Job" href="#gcip.core.job.Job">Job</a>,Â JobSequence]) â€‘>Â <a title="gcip.core.job.Job" href="#gcip.core.job.Job">Job</a></span>
</code></dt>
<dd>
<div class="desc"><p>Add one or more <a href="https://docs.gitlab.com/ee/ci/yaml/README.html#needs">needs</a> to the job.</p>
<h2 id="args">Args</h2>
<p>*needs (Union[Need, Job, JobSequence]):</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>JobSequence</code></dt>
<dd>Returns the modified <code><a title="gcip.core.job.Job" href="#gcip.core.job.Job">Job</a></code> object.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_needs(self, *needs: Union[Need, Job, JobSequence]) -&gt; Job:
    &#34;&#34;&#34;Add one or more [needs](https://docs.gitlab.com/ee/ci/yaml/README.html#needs) to the job.

    Args:
        *needs (Union[Need, Job, JobSequence]):

    Returns:
        JobSequence: Returns the modified `Job` object.
    &#34;&#34;&#34;
    self._needs.extend(needs)
    return self</code></pre>
</details>
</dd>
<dt id="gcip.core.job.Job.add_tags"><code class="name flex">
<span>def <span class="ident">add_tags</span></span>(<span>self, *tags:Â str) â€‘>Â <a title="gcip.core.job.Job" href="#gcip.core.job.Job">Job</a></span>
</code></dt>
<dd>
<div class="desc"><p>Adds one or more <a href="https://docs.gitlab.com/ee/ci/yaml/README.html#tags">tags</a> to the job.</p>
<h2 id="returns">Returns</h2>
<p><code><a title="gcip.core.job.Job" href="#gcip.core.job.Job">Job</a></code>: The modified <code><a title="gcip.core.job.Job" href="#gcip.core.job.Job">Job</a></code> object.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_tags(self, *tags: str) -&gt; Job:
    &#34;&#34;&#34;Adds one or more [tags](https://docs.gitlab.com/ee/ci/yaml/README.html#tags) to the job.

    Returns:
        `Job`: The modified `Job` object.
    &#34;&#34;&#34;
    for tag in tags:
        self._tags[tag] = None
    return self</code></pre>
</details>
</dd>
<dt id="gcip.core.job.Job.add_variables"><code class="name flex">
<span>def <span class="ident">add_variables</span></span>(<span>self, **variables:Â str) â€‘>Â <a title="gcip.core.job.Job" href="#gcip.core.job.Job">Job</a></span>
</code></dt>
<dd>
<div class="desc"><p>Adds one or more <a href="https://docs.gitlab.com/ee/ci/yaml/README.html#variables">variables</a>, each as keyword argument,
to the job.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>**variables</code></strong> :&ensp;<code>str</code></dt>
<dd>Each variable would be provided as keyword argument:</dd>
</dl>
<pre><code>job.add_variables(GREETING=&quot;hello&quot;, LANGUAGE=&quot;python&quot;)
</code></pre>
<h2 id="returns">Returns</h2>
<p><code><a title="gcip.core.job.Job" href="#gcip.core.job.Job">Job</a></code>: The modified <code><a title="gcip.core.job.Job" href="#gcip.core.job.Job">Job</a></code> object.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_variables(self, **variables: str) -&gt; Job:
    &#34;&#34;&#34;Adds one or more [variables](https://docs.gitlab.com/ee/ci/yaml/README.html#variables), each as keyword argument,
    to the job.

    Args:
        **variables (str): Each variable would be provided as keyword argument:
    ```
    job.add_variables(GREETING=&#34;hello&#34;, LANGUAGE=&#34;python&#34;)
    ```

    Returns:
        `Job`: The modified `Job` object.
    &#34;&#34;&#34;
    self._variables.update(variables)
    return self</code></pre>
</details>
</dd>
<dt id="gcip.core.job.Job.append_rules"><code class="name flex">
<span>def <span class="ident">append_rules</span></span>(<span>self, *rules:Â Rule) â€‘>Â <a title="gcip.core.job.Job" href="#gcip.core.job.Job">Job</a></span>
</code></dt>
<dd>
<div class="desc"><p>Adds one or more
<a href="https://docs.gitlab.com/ee/ci/yaml/README.html#rules">rule</a>s behind the current rules of the job.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>*rules</code></strong> :&ensp;<code>Rule</code></dt>
<dd>See <code><a title="gcip.core.rule.Rule" href="rule.html#gcip.core.rule.Rule">Rule</a></code> class.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>JobSequence</code></dt>
<dd>Returns the modified <code><a title="gcip.core.job.Job" href="#gcip.core.job.Job">Job</a></code> object.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def append_rules(self, *rules: Rule) -&gt; Job:
    &#34;&#34;&#34;Adds one or more  [rule](https://docs.gitlab.com/ee/ci/yaml/README.html#rules)s behind the current rules of the job.

    Args:
        *rules (Rule): See `gcip.core.rule.Rule` class.

    Returns:
        JobSequence: Returns the modified `Job` object.
    &#34;&#34;&#34;
    self._rules.extend(rules)
    return self</code></pre>
</details>
</dd>
<dt id="gcip.core.job.Job.append_scripts"><code class="name flex">
<span>def <span class="ident">append_scripts</span></span>(<span>self, *scripts:Â str) â€‘>Â <a title="gcip.core.job.Job" href="#gcip.core.job.Job">Job</a></span>
</code></dt>
<dd>
<div class="desc"><p>Adds one or more <a href="https://docs.gitlab.com/ee/ci/yaml/README.html#script">script</a>s after the current scripts.</p>
<h2 id="returns">Returns</h2>
<p><code><a title="gcip.core.job.Job" href="#gcip.core.job.Job">Job</a></code>: The modified <code><a title="gcip.core.job.Job" href="#gcip.core.job.Job">Job</a></code> object.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def append_scripts(self, *scripts: str) -&gt; Job:
    &#34;&#34;&#34;Adds one or more [script](https://docs.gitlab.com/ee/ci/yaml/README.html#script)s after the current scripts.

    Returns:
        `Job`: The modified `Job` object.
    &#34;&#34;&#34;
    self._scripts.extend(scripts)
    return self</code></pre>
</details>
</dd>
<dt id="gcip.core.job.Job.copy"><code class="name flex">
<span>def <span class="ident">copy</span></span>(<span>self) â€‘>Â <a title="gcip.core.job.Job" href="#gcip.core.job.Job">Job</a></span>
</code></dt>
<dd>
<div class="desc"><p>Returns a independent, deep copy object of this job.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def copy(self) -&gt; Job:
    &#34;&#34;&#34;Returns a independent, deep copy object of this job.&#34;&#34;&#34;
    return self._copy_into(Job(name=&#34;&lt;set in _copy_into()&#34;, script=copy.deepcopy(self._scripts)))</code></pre>
</details>
</dd>
<dt id="gcip.core.job.Job.prepend_rules"><code class="name flex">
<span>def <span class="ident">prepend_rules</span></span>(<span>self, *rules:Â Rule) â€‘>Â <a title="gcip.core.job.Job" href="#gcip.core.job.Job">Job</a></span>
</code></dt>
<dd>
<div class="desc"><p>Inserts one or more
<a href="https://docs.gitlab.com/ee/ci/yaml/README.html#rules">rule</a>s before the current rules of the job.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>*rules</code></strong> :&ensp;<code>Rule</code></dt>
<dd>See <code><a title="gcip.core.rule.Rule" href="rule.html#gcip.core.rule.Rule">Rule</a></code> class.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>JobSequence</code></dt>
<dd>Returns the modified <code><a title="gcip.core.job.Job" href="#gcip.core.job.Job">Job</a></code> object.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def prepend_rules(self, *rules: Rule) -&gt; Job:
    &#34;&#34;&#34;Inserts one or more  [rule](https://docs.gitlab.com/ee/ci/yaml/README.html#rules)s before the current rules of the job.

    Args:
        *rules (Rule): See `gcip.core.rule.Rule` class.

    Returns:
        JobSequence: Returns the modified `Job` object.
    &#34;&#34;&#34;
    self._rules = list(rules) + self._rules
    return self</code></pre>
</details>
</dd>
<dt id="gcip.core.job.Job.prepend_scripts"><code class="name flex">
<span>def <span class="ident">prepend_scripts</span></span>(<span>self, *scripts:Â str) â€‘>Â <a title="gcip.core.job.Job" href="#gcip.core.job.Job">Job</a></span>
</code></dt>
<dd>
<div class="desc"><p>Inserts one or more <a href="https://docs.gitlab.com/ee/ci/yaml/README.html#script">script</a>s before the current scripts.</p>
<h2 id="returns">Returns</h2>
<p><code><a title="gcip.core.job.Job" href="#gcip.core.job.Job">Job</a></code>: The modified <code><a title="gcip.core.job.Job" href="#gcip.core.job.Job">Job</a></code> object.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def prepend_scripts(self, *scripts: str) -&gt; Job:
    &#34;&#34;&#34;Inserts one or more [script](https://docs.gitlab.com/ee/ci/yaml/README.html#script)s before the current scripts.

    Returns:
        `Job`: The modified `Job` object.
    &#34;&#34;&#34;
    self._scripts = list(scripts) + self._scripts
    return self</code></pre>
</details>
</dd>
<dt id="gcip.core.job.Job.render"><code class="name flex">
<span>def <span class="ident">render</span></span>(<span>self) â€‘>Â Dict[str,Â Any]</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def render(self) -&gt; Dict[str, Any]:
    from .job_sequence import \
        JobSequence  # late import to avoid circular dependencies

    rendered_job: Dict[str, Any] = {}

    if self._image:
        rendered_job.update({&#34;image&#34;: self._image.render()})

    if self._needs:
        need_jobs: List[Job] = list()
        rendered_needs: List[Dict[str, Union[str, bool]]] = list()
        for need in self._needs:
            if isinstance(need, Job):
                need_jobs.append(need)
            elif isinstance(need, JobSequence):
                for job in need.last_jobs_executed:
                    need_jobs.append(job)
            elif isinstance(need, Need):
                rendered_needs.append(need.render())
            else:
                raise TypeError(f&#34;Need &#39;{need}&#39; is of type {type(need)}.&#34;)

        job_names: Set[str] = set()
        for job in need_jobs:
            job_names.update(job._get_all_instance_names())

        for name in job_names:
            rendered_needs.append(Need(name).render())

        # sort needs by the name of the referenced job
        rendered_needs = sorted(rendered_needs, key=itemgetter(&#34;job&#34;))

        rendered_job.update({&#34;needs&#34;: rendered_needs})

    rendered_job.update({
        &#34;stage&#34;: self._stage,
        &#34;script&#34;: self._scripts,
    })

    if self._variables:
        rendered_job[&#34;variables&#34;] = self._variables

    if self._rules:
        rendered_rules = []
        for rule in self._rules:
            rendered_rules.append(rule.render())
        rendered_job.update({&#34;rules&#34;: rendered_rules})

    if self._artifacts_paths.keys():
        rendered_job.update({&#34;artifacts&#34;: {
            &#34;paths&#34;: list(self._artifacts_paths.keys()),
        }})

    if self._cache:
        rendered_job.update({&#34;cache&#34;: self._cache.render()})

    if self._tags.keys():
        rendered_job[&#34;tags&#34;] = list(self._tags.keys())

    return rendered_job</code></pre>
</details>
</dd>
<dt id="gcip.core.job.Job.set_cache"><code class="name flex">
<span>def <span class="ident">set_cache</span></span>(<span>self, cache:Â Optional[Cache]) â€‘>Â <a title="gcip.core.job.Job" href="#gcip.core.job.Job">Job</a></span>
</code></dt>
<dd>
<div class="desc"><p>Sets the <a href="https://docs.gitlab.com/ee/ci/yaml/README.html#cache">cache</a> of the Job.</p>
<p>Any previous values will be overwritten.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>cache</code></strong> :&ensp;<code>Optional[Cache]</code></dt>
<dd>See <code><a title="gcip.core.cache.Cache" href="cache.html#gcip.core.cache.Cache">Cache</a></code> class.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>JobSequence</code></dt>
<dd>Returns the modified <code><a title="gcip.core.job.Job" href="#gcip.core.job.Job">Job</a></code> object.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_cache(self, cache: Optional[Cache]) -&gt; Job:
    &#34;&#34;&#34;Sets the [cache](https://docs.gitlab.com/ee/ci/yaml/README.html#cache) of the Job.

    Any previous values will be overwritten.

    Args:
        cache (Optional[Cache]): See `gcip.core.cache.Cache` class.

    Returns:
        JobSequence: Returns the modified `Job` object.
    &#34;&#34;&#34;
    if cache:
        self._cache = cache
    return self</code></pre>
</details>
</dd>
<dt id="gcip.core.job.Job.set_image"><code class="name flex">
<span>def <span class="ident">set_image</span></span>(<span>self, image:Â Optional[Union[Image,Â str]]) â€‘>Â <a title="gcip.core.job.Job" href="#gcip.core.job.Job">Job</a></span>
</code></dt>
<dd>
<div class="desc"><p>Sets the image of this job.</p>
<p>For a simple container image you can provide the origin of the image.
If you want to set the entrypoint, you have to provide an Image object instead.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>image</code></strong> :&ensp;<code>Optional[Union[Image, str]]</code></dt>
<dd>Can be either <code>string</code> or <code>Image</code>.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="gcip.core.job.Job" href="#gcip.core.job.Job">Job</a></code></dt>
<dd>Returns the modified :class:<code><a title="gcip.core.job.Job" href="#gcip.core.job.Job">Job</a></code> object.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_image(self, image: Optional[Union[Image, str]]) -&gt; Job:
    &#34;&#34;&#34;Sets the image of this job.

    For a simple container image you can provide the origin of the image.
    If you want to set the entrypoint, you have to provide an Image object instead.

    Args:
        image (Optional[Union[Image, str]]): Can be either `string` or `Image`.

    Returns:
        Job: Returns the modified :class:`Job` object.
    &#34;&#34;&#34;
    if image:
        if isinstance(image, str):
            image = Image(image)
        self._image = image
    return self</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="gcip.core.job.TriggerJob"><code class="flex name class">
<span>class <span class="ident">TriggerJob</span></span>
<span>(</span><span>*args:Â Any, name:Â Optional[str]Â =Â None, namespace:Â Optional[str]Â =Â None, project:Â Optional[str]Â =Â None, branch:Â Optional[str]Â =Â None, includes:Â Union[Include,Â List[Include],Â None]Â =Â None, strategy:Â Optional[<a title="gcip.core.job.TriggerStrategy" href="#gcip.core.job.TriggerStrategy">TriggerStrategy</a>]Â =Â None, **kwargs:Â Mapping[Any,Â Any])</span>
</code></dt>
<dd>
<div class="desc"><p>This class represents the Gitlab CI <a href="https://docs.gitlab.com/ee/ci/yaml/README.html#job-keywords">Job</a></p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>script</code></strong> :&ensp;<code>Union[AnyStr, List[str]]</code></dt>
<dd>The <a href="https://docs.gitlab.com/ee/ci/yaml/README.html#script">script(s)</a> to be executed.</dd>
<dt><strong><code>name</code></strong> :&ensp;<code>Optional[str]</code></dt>
<dd>The name of the job. In opposite to <code>namespace</code> only the name is set and not the stage of the job.
If <code>name</code> is set, than the jobs stage has no value, which defaults to the 'test' stage.
Either <code>name</code> or <code>namespace</code> must be set. Defaults to <code>None</code>.</dd>
<dt><strong><code>namespace</code></strong> :&ensp;<code>Optional[str]</code></dt>
<dd>The name and stage of the job. In opposite to <code>name</code> also the jobs stage will be setup with this value.
Either <code>name</code> or <code>namespace</code> must be set. Defaults to <code>None</code>.</dd>
</dl>
<p>Class to create a Gitlab CI Trigger.</p>
<p>You can create either a "Parent-child" or a "Multi-project" pipeline trigger.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>project</code></strong> :&ensp;<code>Optional[str]</code></dt>
<dd>Used to create Multi-project pipeline trigger, exclusive to <code>includes</code> given Gitlab project name.
e.g 'team1/project1'. Defaults to None.</dd>
<dt><strong><code>branch</code></strong> :&ensp;<code>Optional[str]</code></dt>
<dd>If <code>project</code> is given, you can specify which branch of <code>project</code> to trigger. Defaults to None.</dd>
<dt><strong><code>includes</code></strong> :&ensp;<code>Optional[List[Include]]</code></dt>
<dd>Used to create Parent-child pipeline trigger, exclusiv to <code>project</code>. Defaults to None.</dd>
<dt><strong><code>strategy</code></strong> :&ensp;<code>Optional[<a title="gcip.core.job.TriggerStrategy" href="#gcip.core.job.TriggerStrategy">TriggerStrategy</a>]</code></dt>
<dd>Strategy of how the job behaves from the upstream pipeline.
If :class:<code><a title="gcip.core.job.TriggerStrategy.DEPEND" href="#gcip.core.job.TriggerStrategy.DEPEND">TriggerStrategy.DEPEND</a></code>, any triggered job failed this job failed as well. Defaults to None.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>ValueError</code></dt>
<dd>If <code>project</code> and <code>includes</code> is given at the same time.</dd>
<dt><code>ValueError</code></dt>
<dd>There is a Gitlab CI limitation, in "Parent-child" pipelines it is only allowed to add max. three includes.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class TriggerJob(Job):
    def __init__(
        self,
        *args: Any,
        name: Optional[str] = None,
        namespace: Optional[str] = None,
        project: Optional[str] = None,
        branch: Optional[str] = None,
        includes: Union[Include, List[Include], None] = None,
        strategy: Optional[TriggerStrategy] = None,
        **kwargs: Mapping[Any, Any],
    ) -&gt; None:
        &#34;&#34;&#34;
        Class to create a Gitlab CI Trigger.

        You can create either a &#34;Parent-child&#34; or a &#34;Multi-project&#34; pipeline trigger.


        Args:
            project (Optional[str]): Used to create Multi-project pipeline trigger, exclusive to ``includes`` given Gitlab project name.
                e.g &#39;team1/project1&#39;. Defaults to None.
            branch (Optional[str]): If ``project`` is given, you can specify which branch of ``project`` to trigger. Defaults to None.
            includes (Optional[List[Include]]): Used to create Parent-child pipeline trigger, exclusiv to ``project``. Defaults to None.
            strategy (Optional[TriggerStrategy]): Strategy of how the job behaves from the upstream pipeline.
                If :class:`TriggerStrategy.DEPEND`, any triggered job failed this job failed as well. Defaults to None.

        Raises:
            ValueError: If ``project`` and ``includes`` is given at the same time.
            ValueError: There is a Gitlab CI limitation, in &#34;Parent-child&#34; pipelines it is only allowed to add max. three includes.
        &#34;&#34;&#34;

        if includes and project:
            raise ValueError((&#34;You cannot specify &#39;include&#39; and &#39;project&#39; together. Either &#39;include&#39; or &#39;project&#39; is possible.&#34;))
        if not includes and not project:
            raise ValueError(&#34;Neither &#39;includes&#39; nor &#39;project&#39; is given.&#34;)

        super().__init__(name=name, namespace=namespace, script=&#34;none&#34;)

        self._project = project
        self._branch = branch
        self._strategy = strategy

        if not includes:
            self._includes = None
        elif isinstance(includes, Include):
            self._includes = [includes]
        elif isinstance(includes, list):
            if len(includes) &gt; 3:
                raise ValueError(
                    (
                        &#34;The length of &#39;includes&#39; is limited to three.&#34;
                        &#34;See https://docs.gitlab.com/ee/ci/parent_child_pipelines.html for more information.&#34;
                    )
                )
            self._includes = includes
        else:
            raise AttributeError(&#34;script parameter must be of type string or list of strings&#34;)

    def copy(self) -&gt; TriggerJob:
        job_copy = TriggerJob(name=&#34;.&#34;, project=&#34;.&#34;)
        super()._copy_into(job_copy)

        job_copy._project = self._project
        job_copy._branch = self._branch
        job_copy._includes = self._includes
        job_copy._strategy = self._strategy
        return job_copy

    def render(self) -&gt; Dict[Any, Any]:
        rendered_job = super().render()

        # remove unsupported keywords from TriggerJob
        rendered_job.pop(&#34;script&#34;)

        if &#34;image&#34; in rendered_job:
            rendered_job.pop(&#34;image&#34;)

        if &#34;tags&#34; in rendered_job:
            rendered_job.pop(&#34;tags&#34;)

        if &#34;artifacts&#34; in rendered_job:
            rendered_job.pop(&#34;artifacts&#34;)

        if &#34;cache&#34; in rendered_job:
            rendered_job.pop(&#34;cache&#34;)

        trigger: Dict[str, Union[str, List[Dict[str, str]]]] = {}

        # Child pipelines
        if self._includes:
            trigger.update({
                &#34;include&#34;: [include.render() for include in self._includes],
            })

        # Multiproject pipelines
        if self._project:
            trigger.update({
                &#34;project&#34;: self._project,
            })
            if self._branch:
                trigger.update({&#34;branch&#34;: self._branch})

        if self._strategy:
            trigger.update({&#34;strategy&#34;: self._strategy.value})

        rendered_job = {
            &#34;trigger&#34;: trigger,
            **rendered_job
        }

        return rendered_job</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="gcip.core.job.Job" href="#gcip.core.job.Job">Job</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="gcip.core.job.TriggerJob.render"><code class="name flex">
<span>def <span class="ident">render</span></span>(<span>self) â€‘>Â Dict[Any,Â Any]</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def render(self) -&gt; Dict[Any, Any]:
    rendered_job = super().render()

    # remove unsupported keywords from TriggerJob
    rendered_job.pop(&#34;script&#34;)

    if &#34;image&#34; in rendered_job:
        rendered_job.pop(&#34;image&#34;)

    if &#34;tags&#34; in rendered_job:
        rendered_job.pop(&#34;tags&#34;)

    if &#34;artifacts&#34; in rendered_job:
        rendered_job.pop(&#34;artifacts&#34;)

    if &#34;cache&#34; in rendered_job:
        rendered_job.pop(&#34;cache&#34;)

    trigger: Dict[str, Union[str, List[Dict[str, str]]]] = {}

    # Child pipelines
    if self._includes:
        trigger.update({
            &#34;include&#34;: [include.render() for include in self._includes],
        })

    # Multiproject pipelines
    if self._project:
        trigger.update({
            &#34;project&#34;: self._project,
        })
        if self._branch:
            trigger.update({&#34;branch&#34;: self._branch})

    if self._strategy:
        trigger.update({&#34;strategy&#34;: self._strategy.value})

    rendered_job = {
        &#34;trigger&#34;: trigger,
        **rendered_job
    }

    return rendered_job</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="gcip.core.job.Job" href="#gcip.core.job.Job">Job</a></b></code>:
<ul class="hlist">
<li><code><a title="gcip.core.job.Job.add_artifacts_paths" href="#gcip.core.job.Job.add_artifacts_paths">add_artifacts_paths</a></code></li>
<li><code><a title="gcip.core.job.Job.add_needs" href="#gcip.core.job.Job.add_needs">add_needs</a></code></li>
<li><code><a title="gcip.core.job.Job.add_tags" href="#gcip.core.job.Job.add_tags">add_tags</a></code></li>
<li><code><a title="gcip.core.job.Job.add_variables" href="#gcip.core.job.Job.add_variables">add_variables</a></code></li>
<li><code><a title="gcip.core.job.Job.append_rules" href="#gcip.core.job.Job.append_rules">append_rules</a></code></li>
<li><code><a title="gcip.core.job.Job.append_scripts" href="#gcip.core.job.Job.append_scripts">append_scripts</a></code></li>
<li><code><a title="gcip.core.job.Job.copy" href="#gcip.core.job.Job.copy">copy</a></code></li>
<li><code><a title="gcip.core.job.Job.name" href="#gcip.core.job.Job.name">name</a></code></li>
<li><code><a title="gcip.core.job.Job.prepend_rules" href="#gcip.core.job.Job.prepend_rules">prepend_rules</a></code></li>
<li><code><a title="gcip.core.job.Job.prepend_scripts" href="#gcip.core.job.Job.prepend_scripts">prepend_scripts</a></code></li>
<li><code><a title="gcip.core.job.Job.set_cache" href="#gcip.core.job.Job.set_cache">set_cache</a></code></li>
<li><code><a title="gcip.core.job.Job.set_image" href="#gcip.core.job.Job.set_image">set_image</a></code></li>
<li><code><a title="gcip.core.job.Job.stage" href="#gcip.core.job.Job.stage">stage</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="gcip.core.job.TriggerStrategy"><code class="flex name class">
<span>class <span class="ident">TriggerStrategy</span></span>
<span>(</span><span>value, names=None, *, module=None, qualname=None, type=None, start=1)</span>
</code></dt>
<dd>
<div class="desc"><p>Class with static values for <code><a title="gcip.core.job.TriggerStrategy" href="#gcip.core.job.TriggerStrategy">TriggerStrategy</a></code> used together with :class:<code><a title="gcip.core.job.TriggerJob" href="#gcip.core.job.TriggerJob">TriggerJob</a></code>. To construct an object.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class TriggerStrategy(Enum):
    &#34;&#34;&#34;Class with static values for ``TriggerStrategy`` used together with :class:`gcip.core.job.TriggerJob`. To construct an object.&#34;&#34;&#34;
    DEPEND = &#34;depend&#34;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>enum.Enum</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="gcip.core.job.TriggerStrategy.DEPEND"><code class="name">var <span class="ident">DEPEND</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="gcip.core" href="index.html">gcip.core</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="gcip.core.job.Job" href="#gcip.core.job.Job">Job</a></code></h4>
<ul class="two-column">
<li><code><a title="gcip.core.job.Job.add_artifacts_paths" href="#gcip.core.job.Job.add_artifacts_paths">add_artifacts_paths</a></code></li>
<li><code><a title="gcip.core.job.Job.add_needs" href="#gcip.core.job.Job.add_needs">add_needs</a></code></li>
<li><code><a title="gcip.core.job.Job.add_tags" href="#gcip.core.job.Job.add_tags">add_tags</a></code></li>
<li><code><a title="gcip.core.job.Job.add_variables" href="#gcip.core.job.Job.add_variables">add_variables</a></code></li>
<li><code><a title="gcip.core.job.Job.append_rules" href="#gcip.core.job.Job.append_rules">append_rules</a></code></li>
<li><code><a title="gcip.core.job.Job.append_scripts" href="#gcip.core.job.Job.append_scripts">append_scripts</a></code></li>
<li><code><a title="gcip.core.job.Job.copy" href="#gcip.core.job.Job.copy">copy</a></code></li>
<li><code><a title="gcip.core.job.Job.name" href="#gcip.core.job.Job.name">name</a></code></li>
<li><code><a title="gcip.core.job.Job.prepend_rules" href="#gcip.core.job.Job.prepend_rules">prepend_rules</a></code></li>
<li><code><a title="gcip.core.job.Job.prepend_scripts" href="#gcip.core.job.Job.prepend_scripts">prepend_scripts</a></code></li>
<li><code><a title="gcip.core.job.Job.render" href="#gcip.core.job.Job.render">render</a></code></li>
<li><code><a title="gcip.core.job.Job.set_cache" href="#gcip.core.job.Job.set_cache">set_cache</a></code></li>
<li><code><a title="gcip.core.job.Job.set_image" href="#gcip.core.job.Job.set_image">set_image</a></code></li>
<li><code><a title="gcip.core.job.Job.stage" href="#gcip.core.job.Job.stage">stage</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="gcip.core.job.TriggerJob" href="#gcip.core.job.TriggerJob">TriggerJob</a></code></h4>
<ul class="">
<li><code><a title="gcip.core.job.TriggerJob.render" href="#gcip.core.job.TriggerJob.render">render</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="gcip.core.job.TriggerStrategy" href="#gcip.core.job.TriggerStrategy">TriggerStrategy</a></code></h4>
<ul class="">
<li><code><a title="gcip.core.job.TriggerStrategy.DEPEND" href="#gcip.core.job.TriggerStrategy.DEPEND">DEPEND</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.2</a>.</p>
</footer>
</body>
</html>