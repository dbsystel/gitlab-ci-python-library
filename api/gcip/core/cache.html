<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2" />
<title>gcip.core.cache API documentation</title>
<meta name="description" content="This module represents the Gitlab CI [cache](https://docs.gitlab.com/ee/ci/yaml/#cache) keyword â€¦" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>gcip.core.cache</code></h1>
</header>
<section id="section-intro">
<p>This module represents the Gitlab CI <a href="https://docs.gitlab.com/ee/ci/yaml/#cache">cache</a> keyword</p>
<p>Simple example:</p>
<pre><code>from gcip import Job, Cache

job1 = Job(namespace=&quot;buildit&quot;, script=&quot;build my app&quot;)
job1.set_cache(Cache([&quot;file1.txt&quot;, &quot;file2.txt&quot;, &quot;path/to/file3.txt&quot;]))
</code></pre>
<p>More complex example:</p>
<pre><code>from gcip import Job, Cache, CacheKey, CachePolicy, WhenStatement

files = [&quot;file1.txt&quot;, &quot;file2.txt&quot;, &quot;path/to/file3.txt&quot;]

job1 = Job(namespace=&quot;buildit&quot;, script=&quot;build my app&quot;)
job1.set_cache(Cache(
    files,
    cache_key=CacheKey(files=files),
    when=WhenStatement.ALWAYS,
    policy=CachePolicy.PULL_PUSH))
</code></pre>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;This module represents the Gitlab CI [cache](https://docs.gitlab.com/ee/ci/yaml/#cache) keyword

Simple example:

```
from gcip import Job, Cache

job1 = Job(namespace=&#34;buildit&#34;, script=&#34;build my app&#34;)
job1.set_cache(Cache([&#34;file1.txt&#34;, &#34;file2.txt&#34;, &#34;path/to/file3.txt&#34;]))
```

More complex example:

```
from gcip import Job, Cache, CacheKey, CachePolicy, WhenStatement

files = [&#34;file1.txt&#34;, &#34;file2.txt&#34;, &#34;path/to/file3.txt&#34;]

job1 = Job(namespace=&#34;buildit&#34;, script=&#34;build my app&#34;)
job1.set_cache(Cache(
    files,
    cache_key=CacheKey(files=files),
    when=WhenStatement.ALWAYS,
    policy=CachePolicy.PULL_PUSH))
```
&#34;&#34;&#34;

import re
from enum import Enum
from typing import Any, Dict, List, Union, Optional

from gcip.core.rule import WhenStatement
from gcip.core.variables import PredefinedVariables


class CachePolicy(Enum):
    &#34;&#34;&#34;This class represents the [cache:policy](https://docs.gitlab.com/ee/ci/yaml/#cachepolicy) keyword.

    The policy determines if a Job can modify the cache or read him only.
    &#34;&#34;&#34;

    PULL_PUSH = &#34;pull-push&#34;
    &#34;&#34;&#34;
    The default behavior of a caching job is to download the files at the start of execution, and to
    re-upload them at the end. Any changes made by the job are persisted for future runs.
    &#34;&#34;&#34;

    PULL = &#34;pull&#34;
    &#34;&#34;&#34;
    If you know the job does not alter the cached files, you can skip the upload step by setting this policy in the job specification.
    &#34;&#34;&#34;


class CacheKey():
    &#34;&#34;&#34;This class represents the [cache:key](https://docs.gitlab.com/ee/ci/yaml/#cachekey) keyword.

    Gitlab CI documentation: _&#34;The key keyword defines the affinity of caching between jobs. You can have a single cache for
    all jobs, cache per-job, cache per-branch, or any other way that fits your workflow.&#34;_

    Args:
        key (Optional[str]): The key is the unique id of the cache. `gcip.core.job.Job`s referencing caches with the same key are
            sharing the cache contents. Mutually exclusive with `files`. Defaults to
            `gcip.core.variables.PredefinedVariables.CI_COMMIT_REF_SLUG` if neither `key` nor `files` is set.
        files (Optional[list]): A set of files is another way to define a caches unique id. Jobs referencing caches with the same
            set of files are sharing the cache contents. The [cache:key:files](https://docs.gitlab.com/ee/ci/yaml/#cachekeyfiles) keyword
            extends the cache:key functionality by making it easier to reuse some caches, and rebuild them less often, which speeds up
            subsequent pipeline runs. Mutually exclusive with `keys`. Defaults to None.
        prefix (Optional[str]): Prefix prefixed given `files` to allow creation of caches for branches. Defaults to None.

    Raises:
        ValueError: If both `key` and `files` are provided.
        ValueError: If both `key` and `prefix` are provided.
        ValueError: If `prefix` but not `files` is provided.
        ValueError: If `key` is only made out of dots &#39;.&#39;.
    &#34;&#34;&#34;
    def __init__(self, key: Optional[str] = None, *, files: Optional[List[str]] = None, prefix: Optional[str] = None) -&gt; None:
        self._key = key
        self._files = files
        self._prefix = prefix

        if self._key and self._files:
            raise ValueError(&#34;Parameters key and files are mutually exclusive.&#34;)
        elif self._prefix and not self._files:
            raise ValueError(&#34;Parameter &#39;prefix&#39; can only be used together with &#39;files&#39;.&#34;)

        if self._files is None and self._key is None:
            self._key = PredefinedVariables.CI_COMMIT_REF_SLUG

        if self._key:
            # Forward slash not allowed for cache key,
            # therefore converting slash to underscore
            self._key.replace(&#34;/&#34;, &#34;_&#34;)

            if re.match(r&#34;^\.*$&#34;, self._key):
                raise ValueError(&#34;The cache key cannot be a value only made of &#39;.&#39;&#34;)

    @property
    def key(self) -&gt; Optional[str]:
        &#34;&#34;&#34;Equals the identical Class argument.&#34;&#34;&#34;
        return self._key

    @property
    def files(self) -&gt; Optional[List[str]]:
        &#34;&#34;&#34;Equals the identical Class argument.&#34;&#34;&#34;
        return self._files

    @property
    def prefix(self) -&gt; Optional[str]:
        &#34;&#34;&#34;Equals the identical Class argument.&#34;&#34;&#34;
        return self._prefix

    def render(self) -&gt; Union[str, Dict[str, Union[List[str], str]]]:
        &#34;&#34;&#34;Return a representation of this cache key object as string or dictionary with static values.

        The rendered representation is used by the gcip to dump it
        in YAML format as part of the .gitlab-ci.yml pipeline.

        Returns:
            Union[str, Dict[str, Union[List[str], str]]]: A string or dictionary prepresenting the cache object in Gitlab CI.
        &#34;&#34;&#34;
        rendered: Union[str, Dict[str, Union[List[str], str]]]
        if self._key:
            rendered = self._key
        else:
            rendered = {}
            if self._files:
                rendered[&#34;files&#34;] = self._files
            if self._prefix:
                rendered[&#34;prefix&#34;] = self._prefix
        return rendered


class Cache():
    &#34;&#34;&#34;This class represents the [cache](https://docs.gitlab.com/ee/ci/yaml/#cache) keyword.

    Gitlab CI documentation: _&#34;Use cache to specify a list of files and directories to cache between `gcip.core.job.Job`s.
    [...] Caching is shared between `gcip.core.pipeline.Pipeline`s and `gcip.core.job.Job`s. Caches are restored before artifacts.&#34;_

    Args:
        paths (str): Use the [paths directive](https://docs.gitlab.com/ee/ci/yaml/#cachepaths) to choose which
            files or directories to cache. Could be one or more path strings.
        cache_key (Optional[CacheKey]): The key keyword defines the affinity of caching between jobs.
            Defaults to `CacheKey` with default arguments.
        untracked (Optional[bool]): Set the [untracked keyword](https://docs.gitlab.com/ee/ci/yaml/#cacheuntracked) to `True` to cache
            all files that are untracked in your Git repository. Defaults to None (unset).
        when (Optional[WhenStatement]): [This keyword](https://docs.gitlab.com/ee/ci/yaml/#cachewhen) defines when to save the cache,
            depending on job status. Possible values are `gcip.core.rule.WhenStatement.ON_SUCCESS`,
            `gcip.core.rule.WhenStatement.ON_FAILURE`, `gcip.core.rule.WhenStatement.ALWAYS`. Defaults to None (unset).
        policy (Optional[CachePolicy]): The `CachePolicy` determines if a Job can modify the cache or read him only.
            Defaults to None (unset).

    Raises:
        ValueError: For unsupported values for the `when` parameter.
    &#34;&#34;&#34;
    def __init__(
        self,
        paths: str,
        cache_key: Optional[CacheKey] = None,
        untracked: Optional[bool] = None,
        when: Optional[WhenStatement] = None,
        policy: Optional[CachePolicy] = None,
    ) -&gt; None:
        self._paths = []
        self._untracked = untracked
        self._when = when
        self._policy = policy

        # Remove project path prefix from paths given.
        # Prepend ./ to path to clearify that cache paths
        # are relative to CI_PROJECT_PATH
        for path in paths:
            if PredefinedVariables.CI_PROJECT_PATH and path.startswith(PredefinedVariables.CI_PROJECT_PATH):
                path = path[len(PredefinedVariables.CI_PROJECT_PATH):]

            if not path.startswith(&#34;./&#34;):
                path = &#34;./&#34; + path
            self._paths.append(path)

        # Get default CacheKey = PredefinedVariables.CI_COMMIT_REF_SLUG
        if cache_key:
            self._cache_key = cache_key
        else:
            self._cache_key = CacheKey()

        allowed_when_statements = [WhenStatement.ON_SUCCESS, WhenStatement.ON_FAILURE, WhenStatement.ALWAYS]
        if self._when and self._when not in allowed_when_statements:
            raise ValueError(f&#34;{self._when} is not allowed. Allowed when statements: {allowed_when_statements}&#34;)

    @property
    def paths(self) -&gt; List[str]:
        &#34;&#34;&#34;Equals the identical Class argument.&#34;&#34;&#34;
        return self._paths

    @property
    def cache_key(self) -&gt; CacheKey:
        &#34;&#34;&#34;Equals the identical Class argument.&#34;&#34;&#34;
        return self._cache_key

    @property
    def untracked(self) -&gt; Optional[bool]:
        &#34;&#34;&#34;Equals the identical Class argument.&#34;&#34;&#34;
        return self._untracked

    @property
    def when(self) -&gt; Optional[WhenStatement]:
        &#34;&#34;&#34;Equals the identical Class argument.&#34;&#34;&#34;
        return self._when

    @property
    def policy(self) -&gt; Optional[CachePolicy]:
        &#34;&#34;&#34;Equals the identical Class argument.&#34;&#34;&#34;
        return self._policy

    def render(self) -&gt; Dict[str, Any]:
        &#34;&#34;&#34;Return a representation of this Cache object as dictionary with static values.

        The rendered representation is used by the gcip to dump it
        in YAML format as part of the .gitlab-ci.yml pipeline.

        Returns:
            Dict[str, Any]: A dictionary prepresenting the cache object in Gitlab CI.
        &#34;&#34;&#34;
        rendered: Dict[str, Union[str, bool, List[str], Union[str, Dict[str, Union[List[str], str]]]]]
        rendered = {
            &#34;paths&#34;: self._paths
        }
        if self._when:
            rendered[&#34;when&#34;] = self._when.value
        if self._untracked:
            rendered[&#34;untracked&#34;] = self._untracked
        if self._policy:
            rendered[&#34;policy&#34;] = self._policy.value
        rendered[&#34;key&#34;] = self._cache_key.render()

        return rendered</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="gcip.core.cache.Cache"><code class="flex name class">
<span>class <span class="ident">Cache</span></span>
<span>(</span><span>paths:Â str, cache_key:Â Optional[<a title="gcip.core.cache.CacheKey" href="#gcip.core.cache.CacheKey">CacheKey</a>]Â =Â None, untracked:Â Optional[bool]Â =Â None, when:Â Optional[<a title="gcip.core.rule.WhenStatement" href="rule.html#gcip.core.rule.WhenStatement">WhenStatement</a>]Â =Â None, policy:Â Optional[<a title="gcip.core.cache.CachePolicy" href="#gcip.core.cache.CachePolicy">CachePolicy</a>]Â =Â None)</span>
</code></dt>
<dd>
<div class="desc"><p>This class represents the <a href="https://docs.gitlab.com/ee/ci/yaml/#cache">cache</a> keyword.</p>
<p>Gitlab CI documentation: <em>"Use cache to specify a list of files and directories to cache between <code><a title="gcip.core.job.Job" href="job.html#gcip.core.job.Job">Job</a></code>s.
[&hellip;] Caching is shared between <code><a title="gcip.core.pipeline.Pipeline" href="pipeline.html#gcip.core.pipeline.Pipeline">Pipeline</a></code>s and <code><a title="gcip.core.job.Job" href="job.html#gcip.core.job.Job">Job</a></code>s. Caches are restored before artifacts."</em></p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>paths</code></strong> :&ensp;<code>str</code></dt>
<dd>Use the <a href="https://docs.gitlab.com/ee/ci/yaml/#cachepaths">paths directive</a> to choose which
files or directories to cache. Could be one or more path strings.</dd>
<dt><strong><code>cache_key</code></strong> :&ensp;<code>Optional[<a title="gcip.core.cache.CacheKey" href="#gcip.core.cache.CacheKey">CacheKey</a>]</code></dt>
<dd>The key keyword defines the affinity of caching between jobs.
Defaults to <code><a title="gcip.core.cache.CacheKey" href="#gcip.core.cache.CacheKey">CacheKey</a></code> with default arguments.</dd>
<dt><strong><code>untracked</code></strong> :&ensp;<code>Optional[bool]</code></dt>
<dd>Set the <a href="https://docs.gitlab.com/ee/ci/yaml/#cacheuntracked">untracked keyword</a> to <code>True</code> to cache
all files that are untracked in your Git repository. Defaults to None (unset).</dd>
<dt><strong><code>when</code></strong> :&ensp;<code>Optional[WhenStatement]</code></dt>
<dd><a href="https://docs.gitlab.com/ee/ci/yaml/#cachewhen">This keyword</a> defines when to save the cache,
depending on job status. Possible values are <code><a title="gcip.core.rule.WhenStatement.ON_SUCCESS" href="rule.html#gcip.core.rule.WhenStatement.ON_SUCCESS">WhenStatement.ON_SUCCESS</a></code>,
<code><a title="gcip.core.rule.WhenStatement.ON_FAILURE" href="rule.html#gcip.core.rule.WhenStatement.ON_FAILURE">WhenStatement.ON_FAILURE</a></code>, <code><a title="gcip.core.rule.WhenStatement.ALWAYS" href="rule.html#gcip.core.rule.WhenStatement.ALWAYS">WhenStatement.ALWAYS</a></code>. Defaults to None (unset).</dd>
<dt><strong><code>policy</code></strong> :&ensp;<code>Optional[<a title="gcip.core.cache.CachePolicy" href="#gcip.core.cache.CachePolicy">CachePolicy</a>]</code></dt>
<dd>The <code><a title="gcip.core.cache.CachePolicy" href="#gcip.core.cache.CachePolicy">CachePolicy</a></code> determines if a Job can modify the cache or read him only.
Defaults to None (unset).</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>ValueError</code></dt>
<dd>For unsupported values for the <code>when</code> parameter.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Cache():
    &#34;&#34;&#34;This class represents the [cache](https://docs.gitlab.com/ee/ci/yaml/#cache) keyword.

    Gitlab CI documentation: _&#34;Use cache to specify a list of files and directories to cache between `gcip.core.job.Job`s.
    [...] Caching is shared between `gcip.core.pipeline.Pipeline`s and `gcip.core.job.Job`s. Caches are restored before artifacts.&#34;_

    Args:
        paths (str): Use the [paths directive](https://docs.gitlab.com/ee/ci/yaml/#cachepaths) to choose which
            files or directories to cache. Could be one or more path strings.
        cache_key (Optional[CacheKey]): The key keyword defines the affinity of caching between jobs.
            Defaults to `CacheKey` with default arguments.
        untracked (Optional[bool]): Set the [untracked keyword](https://docs.gitlab.com/ee/ci/yaml/#cacheuntracked) to `True` to cache
            all files that are untracked in your Git repository. Defaults to None (unset).
        when (Optional[WhenStatement]): [This keyword](https://docs.gitlab.com/ee/ci/yaml/#cachewhen) defines when to save the cache,
            depending on job status. Possible values are `gcip.core.rule.WhenStatement.ON_SUCCESS`,
            `gcip.core.rule.WhenStatement.ON_FAILURE`, `gcip.core.rule.WhenStatement.ALWAYS`. Defaults to None (unset).
        policy (Optional[CachePolicy]): The `CachePolicy` determines if a Job can modify the cache or read him only.
            Defaults to None (unset).

    Raises:
        ValueError: For unsupported values for the `when` parameter.
    &#34;&#34;&#34;
    def __init__(
        self,
        paths: str,
        cache_key: Optional[CacheKey] = None,
        untracked: Optional[bool] = None,
        when: Optional[WhenStatement] = None,
        policy: Optional[CachePolicy] = None,
    ) -&gt; None:
        self._paths = []
        self._untracked = untracked
        self._when = when
        self._policy = policy

        # Remove project path prefix from paths given.
        # Prepend ./ to path to clearify that cache paths
        # are relative to CI_PROJECT_PATH
        for path in paths:
            if PredefinedVariables.CI_PROJECT_PATH and path.startswith(PredefinedVariables.CI_PROJECT_PATH):
                path = path[len(PredefinedVariables.CI_PROJECT_PATH):]

            if not path.startswith(&#34;./&#34;):
                path = &#34;./&#34; + path
            self._paths.append(path)

        # Get default CacheKey = PredefinedVariables.CI_COMMIT_REF_SLUG
        if cache_key:
            self._cache_key = cache_key
        else:
            self._cache_key = CacheKey()

        allowed_when_statements = [WhenStatement.ON_SUCCESS, WhenStatement.ON_FAILURE, WhenStatement.ALWAYS]
        if self._when and self._when not in allowed_when_statements:
            raise ValueError(f&#34;{self._when} is not allowed. Allowed when statements: {allowed_when_statements}&#34;)

    @property
    def paths(self) -&gt; List[str]:
        &#34;&#34;&#34;Equals the identical Class argument.&#34;&#34;&#34;
        return self._paths

    @property
    def cache_key(self) -&gt; CacheKey:
        &#34;&#34;&#34;Equals the identical Class argument.&#34;&#34;&#34;
        return self._cache_key

    @property
    def untracked(self) -&gt; Optional[bool]:
        &#34;&#34;&#34;Equals the identical Class argument.&#34;&#34;&#34;
        return self._untracked

    @property
    def when(self) -&gt; Optional[WhenStatement]:
        &#34;&#34;&#34;Equals the identical Class argument.&#34;&#34;&#34;
        return self._when

    @property
    def policy(self) -&gt; Optional[CachePolicy]:
        &#34;&#34;&#34;Equals the identical Class argument.&#34;&#34;&#34;
        return self._policy

    def render(self) -&gt; Dict[str, Any]:
        &#34;&#34;&#34;Return a representation of this Cache object as dictionary with static values.

        The rendered representation is used by the gcip to dump it
        in YAML format as part of the .gitlab-ci.yml pipeline.

        Returns:
            Dict[str, Any]: A dictionary prepresenting the cache object in Gitlab CI.
        &#34;&#34;&#34;
        rendered: Dict[str, Union[str, bool, List[str], Union[str, Dict[str, Union[List[str], str]]]]]
        rendered = {
            &#34;paths&#34;: self._paths
        }
        if self._when:
            rendered[&#34;when&#34;] = self._when.value
        if self._untracked:
            rendered[&#34;untracked&#34;] = self._untracked
        if self._policy:
            rendered[&#34;policy&#34;] = self._policy.value
        rendered[&#34;key&#34;] = self._cache_key.render()

        return rendered</code></pre>
</details>
<h3>Instance variables</h3>
<dl>
<dt id="gcip.core.cache.Cache.cache_key"><code class="name">var <span class="ident">cache_key</span> :Â <a title="gcip.core.cache.CacheKey" href="#gcip.core.cache.CacheKey">CacheKey</a></code></dt>
<dd>
<div class="desc"><p>Equals the identical Class argument.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def cache_key(self) -&gt; CacheKey:
    &#34;&#34;&#34;Equals the identical Class argument.&#34;&#34;&#34;
    return self._cache_key</code></pre>
</details>
</dd>
<dt id="gcip.core.cache.Cache.paths"><code class="name">var <span class="ident">paths</span> :Â List[str]</code></dt>
<dd>
<div class="desc"><p>Equals the identical Class argument.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def paths(self) -&gt; List[str]:
    &#34;&#34;&#34;Equals the identical Class argument.&#34;&#34;&#34;
    return self._paths</code></pre>
</details>
</dd>
<dt id="gcip.core.cache.Cache.policy"><code class="name">var <span class="ident">policy</span> :Â Optional[<a title="gcip.core.cache.CachePolicy" href="#gcip.core.cache.CachePolicy">CachePolicy</a>]</code></dt>
<dd>
<div class="desc"><p>Equals the identical Class argument.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def policy(self) -&gt; Optional[CachePolicy]:
    &#34;&#34;&#34;Equals the identical Class argument.&#34;&#34;&#34;
    return self._policy</code></pre>
</details>
</dd>
<dt id="gcip.core.cache.Cache.untracked"><code class="name">var <span class="ident">untracked</span> :Â Optional[bool]</code></dt>
<dd>
<div class="desc"><p>Equals the identical Class argument.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def untracked(self) -&gt; Optional[bool]:
    &#34;&#34;&#34;Equals the identical Class argument.&#34;&#34;&#34;
    return self._untracked</code></pre>
</details>
</dd>
<dt id="gcip.core.cache.Cache.when"><code class="name">var <span class="ident">when</span> :Â Optional[<a title="gcip.core.rule.WhenStatement" href="rule.html#gcip.core.rule.WhenStatement">WhenStatement</a>]</code></dt>
<dd>
<div class="desc"><p>Equals the identical Class argument.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def when(self) -&gt; Optional[WhenStatement]:
    &#34;&#34;&#34;Equals the identical Class argument.&#34;&#34;&#34;
    return self._when</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="gcip.core.cache.Cache.render"><code class="name flex">
<span>def <span class="ident">render</span></span>(<span>self) â€‘>Â Dict[str,Â Any]</span>
</code></dt>
<dd>
<div class="desc"><p>Return a representation of this Cache object as dictionary with static values.</p>
<p>The rendered representation is used by the gcip to dump it
in YAML format as part of the .gitlab-ci.yml pipeline.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Dict[str, Any]</code></dt>
<dd>A dictionary prepresenting the cache object in Gitlab CI.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def render(self) -&gt; Dict[str, Any]:
    &#34;&#34;&#34;Return a representation of this Cache object as dictionary with static values.

    The rendered representation is used by the gcip to dump it
    in YAML format as part of the .gitlab-ci.yml pipeline.

    Returns:
        Dict[str, Any]: A dictionary prepresenting the cache object in Gitlab CI.
    &#34;&#34;&#34;
    rendered: Dict[str, Union[str, bool, List[str], Union[str, Dict[str, Union[List[str], str]]]]]
    rendered = {
        &#34;paths&#34;: self._paths
    }
    if self._when:
        rendered[&#34;when&#34;] = self._when.value
    if self._untracked:
        rendered[&#34;untracked&#34;] = self._untracked
    if self._policy:
        rendered[&#34;policy&#34;] = self._policy.value
    rendered[&#34;key&#34;] = self._cache_key.render()

    return rendered</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="gcip.core.cache.CacheKey"><code class="flex name class">
<span>class <span class="ident">CacheKey</span></span>
<span>(</span><span>key:Â Optional[str]Â =Â None, *, files:Â Optional[List[str]]Â =Â None, prefix:Â Optional[str]Â =Â None)</span>
</code></dt>
<dd>
<div class="desc"><p>This class represents the <a href="https://docs.gitlab.com/ee/ci/yaml/#cachekey">cache:key</a> keyword.</p>
<p>Gitlab CI documentation: <em>"The key keyword defines the affinity of caching between jobs. You can have a single cache for
all jobs, cache per-job, cache per-branch, or any other way that fits your workflow."</em></p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>key</code></strong> :&ensp;<code>Optional[str]</code></dt>
<dd>The key is the unique id of the cache. <code><a title="gcip.core.job.Job" href="job.html#gcip.core.job.Job">Job</a></code>s referencing caches with the same key are
sharing the cache contents. Mutually exclusive with <code>files</code>. Defaults to
<code>gcip.core.variables.PredefinedVariables.CI_COMMIT_REF_SLUG</code> if neither <code>key</code> nor <code>files</code> is set.</dd>
<dt><strong><code>files</code></strong> :&ensp;<code>Optional[list]</code></dt>
<dd>A set of files is another way to define a caches unique id. Jobs referencing caches with the same
set of files are sharing the cache contents. The <a href="https://docs.gitlab.com/ee/ci/yaml/#cachekeyfiles">cache:key:files</a> keyword
extends the cache:key functionality by making it easier to reuse some caches, and rebuild them less often, which speeds up
subsequent pipeline runs. Mutually exclusive with <code>keys</code>. Defaults to None.</dd>
<dt><strong><code>prefix</code></strong> :&ensp;<code>Optional[str]</code></dt>
<dd>Prefix prefixed given <code>files</code> to allow creation of caches for branches. Defaults to None.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>ValueError</code></dt>
<dd>If both <code>key</code> and <code>files</code> are provided.</dd>
<dt><code>ValueError</code></dt>
<dd>If both <code>key</code> and <code>prefix</code> are provided.</dd>
<dt><code>ValueError</code></dt>
<dd>If <code>prefix</code> but not <code>files</code> is provided.</dd>
<dt><code>ValueError</code></dt>
<dd>If <code>key</code> is only made out of dots '.'.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class CacheKey():
    &#34;&#34;&#34;This class represents the [cache:key](https://docs.gitlab.com/ee/ci/yaml/#cachekey) keyword.

    Gitlab CI documentation: _&#34;The key keyword defines the affinity of caching between jobs. You can have a single cache for
    all jobs, cache per-job, cache per-branch, or any other way that fits your workflow.&#34;_

    Args:
        key (Optional[str]): The key is the unique id of the cache. `gcip.core.job.Job`s referencing caches with the same key are
            sharing the cache contents. Mutually exclusive with `files`. Defaults to
            `gcip.core.variables.PredefinedVariables.CI_COMMIT_REF_SLUG` if neither `key` nor `files` is set.
        files (Optional[list]): A set of files is another way to define a caches unique id. Jobs referencing caches with the same
            set of files are sharing the cache contents. The [cache:key:files](https://docs.gitlab.com/ee/ci/yaml/#cachekeyfiles) keyword
            extends the cache:key functionality by making it easier to reuse some caches, and rebuild them less often, which speeds up
            subsequent pipeline runs. Mutually exclusive with `keys`. Defaults to None.
        prefix (Optional[str]): Prefix prefixed given `files` to allow creation of caches for branches. Defaults to None.

    Raises:
        ValueError: If both `key` and `files` are provided.
        ValueError: If both `key` and `prefix` are provided.
        ValueError: If `prefix` but not `files` is provided.
        ValueError: If `key` is only made out of dots &#39;.&#39;.
    &#34;&#34;&#34;
    def __init__(self, key: Optional[str] = None, *, files: Optional[List[str]] = None, prefix: Optional[str] = None) -&gt; None:
        self._key = key
        self._files = files
        self._prefix = prefix

        if self._key and self._files:
            raise ValueError(&#34;Parameters key and files are mutually exclusive.&#34;)
        elif self._prefix and not self._files:
            raise ValueError(&#34;Parameter &#39;prefix&#39; can only be used together with &#39;files&#39;.&#34;)

        if self._files is None and self._key is None:
            self._key = PredefinedVariables.CI_COMMIT_REF_SLUG

        if self._key:
            # Forward slash not allowed for cache key,
            # therefore converting slash to underscore
            self._key.replace(&#34;/&#34;, &#34;_&#34;)

            if re.match(r&#34;^\.*$&#34;, self._key):
                raise ValueError(&#34;The cache key cannot be a value only made of &#39;.&#39;&#34;)

    @property
    def key(self) -&gt; Optional[str]:
        &#34;&#34;&#34;Equals the identical Class argument.&#34;&#34;&#34;
        return self._key

    @property
    def files(self) -&gt; Optional[List[str]]:
        &#34;&#34;&#34;Equals the identical Class argument.&#34;&#34;&#34;
        return self._files

    @property
    def prefix(self) -&gt; Optional[str]:
        &#34;&#34;&#34;Equals the identical Class argument.&#34;&#34;&#34;
        return self._prefix

    def render(self) -&gt; Union[str, Dict[str, Union[List[str], str]]]:
        &#34;&#34;&#34;Return a representation of this cache key object as string or dictionary with static values.

        The rendered representation is used by the gcip to dump it
        in YAML format as part of the .gitlab-ci.yml pipeline.

        Returns:
            Union[str, Dict[str, Union[List[str], str]]]: A string or dictionary prepresenting the cache object in Gitlab CI.
        &#34;&#34;&#34;
        rendered: Union[str, Dict[str, Union[List[str], str]]]
        if self._key:
            rendered = self._key
        else:
            rendered = {}
            if self._files:
                rendered[&#34;files&#34;] = self._files
            if self._prefix:
                rendered[&#34;prefix&#34;] = self._prefix
        return rendered</code></pre>
</details>
<h3>Instance variables</h3>
<dl>
<dt id="gcip.core.cache.CacheKey.files"><code class="name">var <span class="ident">files</span> :Â Optional[List[str]]</code></dt>
<dd>
<div class="desc"><p>Equals the identical Class argument.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def files(self) -&gt; Optional[List[str]]:
    &#34;&#34;&#34;Equals the identical Class argument.&#34;&#34;&#34;
    return self._files</code></pre>
</details>
</dd>
<dt id="gcip.core.cache.CacheKey.key"><code class="name">var <span class="ident">key</span> :Â Optional[str]</code></dt>
<dd>
<div class="desc"><p>Equals the identical Class argument.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def key(self) -&gt; Optional[str]:
    &#34;&#34;&#34;Equals the identical Class argument.&#34;&#34;&#34;
    return self._key</code></pre>
</details>
</dd>
<dt id="gcip.core.cache.CacheKey.prefix"><code class="name">var <span class="ident">prefix</span> :Â Optional[str]</code></dt>
<dd>
<div class="desc"><p>Equals the identical Class argument.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def prefix(self) -&gt; Optional[str]:
    &#34;&#34;&#34;Equals the identical Class argument.&#34;&#34;&#34;
    return self._prefix</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="gcip.core.cache.CacheKey.render"><code class="name flex">
<span>def <span class="ident">render</span></span>(<span>self) â€‘>Â Union[str,Â Dict[str,Â Union[List[str],Â str]]]</span>
</code></dt>
<dd>
<div class="desc"><p>Return a representation of this cache key object as string or dictionary with static values.</p>
<p>The rendered representation is used by the gcip to dump it
in YAML format as part of the .gitlab-ci.yml pipeline.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Union[str, Dict[str, Union[List[str], str]]]</code></dt>
<dd>A string or dictionary prepresenting the cache object in Gitlab CI.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def render(self) -&gt; Union[str, Dict[str, Union[List[str], str]]]:
    &#34;&#34;&#34;Return a representation of this cache key object as string or dictionary with static values.

    The rendered representation is used by the gcip to dump it
    in YAML format as part of the .gitlab-ci.yml pipeline.

    Returns:
        Union[str, Dict[str, Union[List[str], str]]]: A string or dictionary prepresenting the cache object in Gitlab CI.
    &#34;&#34;&#34;
    rendered: Union[str, Dict[str, Union[List[str], str]]]
    if self._key:
        rendered = self._key
    else:
        rendered = {}
        if self._files:
            rendered[&#34;files&#34;] = self._files
        if self._prefix:
            rendered[&#34;prefix&#34;] = self._prefix
    return rendered</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="gcip.core.cache.CachePolicy"><code class="flex name class">
<span>class <span class="ident">CachePolicy</span></span>
<span>(</span><span>value, names=None, *, module=None, qualname=None, type=None, start=1)</span>
</code></dt>
<dd>
<div class="desc"><p>This class represents the <a href="https://docs.gitlab.com/ee/ci/yaml/#cachepolicy">cache:policy</a> keyword.</p>
<p>The policy determines if a Job can modify the cache or read him only.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class CachePolicy(Enum):
    &#34;&#34;&#34;This class represents the [cache:policy](https://docs.gitlab.com/ee/ci/yaml/#cachepolicy) keyword.

    The policy determines if a Job can modify the cache or read him only.
    &#34;&#34;&#34;

    PULL_PUSH = &#34;pull-push&#34;
    &#34;&#34;&#34;
    The default behavior of a caching job is to download the files at the start of execution, and to
    re-upload them at the end. Any changes made by the job are persisted for future runs.
    &#34;&#34;&#34;

    PULL = &#34;pull&#34;
    &#34;&#34;&#34;
    If you know the job does not alter the cached files, you can skip the upload step by setting this policy in the job specification.
    &#34;&#34;&#34;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>enum.Enum</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="gcip.core.cache.CachePolicy.PULL"><code class="name">var <span class="ident">PULL</span></code></dt>
<dd>
<div class="desc"><p>If you know the job does not alter the cached files, you can skip the upload step by setting this policy in the job specification.</p></div>
</dd>
<dt id="gcip.core.cache.CachePolicy.PULL_PUSH"><code class="name">var <span class="ident">PULL_PUSH</span></code></dt>
<dd>
<div class="desc"><p>The default behavior of a caching job is to download the files at the start of execution, and to
re-upload them at the end. Any changes made by the job are persisted for future runs.</p></div>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="gcip.core" href="index.html">gcip.core</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="gcip.core.cache.Cache" href="#gcip.core.cache.Cache">Cache</a></code></h4>
<ul class="two-column">
<li><code><a title="gcip.core.cache.Cache.cache_key" href="#gcip.core.cache.Cache.cache_key">cache_key</a></code></li>
<li><code><a title="gcip.core.cache.Cache.paths" href="#gcip.core.cache.Cache.paths">paths</a></code></li>
<li><code><a title="gcip.core.cache.Cache.policy" href="#gcip.core.cache.Cache.policy">policy</a></code></li>
<li><code><a title="gcip.core.cache.Cache.render" href="#gcip.core.cache.Cache.render">render</a></code></li>
<li><code><a title="gcip.core.cache.Cache.untracked" href="#gcip.core.cache.Cache.untracked">untracked</a></code></li>
<li><code><a title="gcip.core.cache.Cache.when" href="#gcip.core.cache.Cache.when">when</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="gcip.core.cache.CacheKey" href="#gcip.core.cache.CacheKey">CacheKey</a></code></h4>
<ul class="">
<li><code><a title="gcip.core.cache.CacheKey.files" href="#gcip.core.cache.CacheKey.files">files</a></code></li>
<li><code><a title="gcip.core.cache.CacheKey.key" href="#gcip.core.cache.CacheKey.key">key</a></code></li>
<li><code><a title="gcip.core.cache.CacheKey.prefix" href="#gcip.core.cache.CacheKey.prefix">prefix</a></code></li>
<li><code><a title="gcip.core.cache.CacheKey.render" href="#gcip.core.cache.CacheKey.render">render</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="gcip.core.cache.CachePolicy" href="#gcip.core.cache.CachePolicy">CachePolicy</a></code></h4>
<ul class="">
<li><code><a title="gcip.core.cache.CachePolicy.PULL" href="#gcip.core.cache.CachePolicy.PULL">PULL</a></code></li>
<li><code><a title="gcip.core.cache.CachePolicy.PULL_PUSH" href="#gcip.core.cache.CachePolicy.PULL_PUSH">PULL_PUSH</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.2</a>.</p>
</footer>
</body>
</html>